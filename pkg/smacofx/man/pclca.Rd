% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/clca.R
\name{pclca}
\alias{pclca}
\alias{clca}
\alias{som_pclca}
\title{Curvilinear Component Analysis with powers}
\usage{
pclca(
  delta,
  kappa = 1,
  tau = 0.1,
  type = c("ratio", "interval", "ordinal"),
  ties = "primary",
  weightmat,
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)

clca(
  delta,
  tau = 0.1,
  type = c("ratio", "interval", "ordinal"),
  ties = "primary",
  weightmat,
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)

som_pclca(
  delta,
  tau = 1,
  epochs = 10,
  kappa = 1,
  type = c("ratio", "interval", "ordinal"),
  ties = "primary",
  weightmat,
  init = NULL,
  ndim = 2,
  acc = 1e-06,
  itmax = 10000,
  verbose = FALSE,
  principal = FALSE
)
}
\arguments{
\item{delta}{dist object or a symmetric, numeric data.frame or matrix of distances}

\item{kappa}{power of the transformation of the fitted distances; defaults to 1 for standard stress}

\item{tau}{the boundary parameter (called lambda in the original paper). For 'pclca' and 'clca' the transformed fitted distances exceeding the parameter are set to 0 via the weightmat. For som_pclca tau is the maximum tau for which a decreasing sequence of taus is generated as 'seq(tau,tau/epochs,length.out=epochs)' and then used in sequence.}

\item{type}{what type of MDS to fit. Currently one of "ratio", "interval" or "ordinal". Default is "ratio".}

\item{ties}{the handling of ties for ordinal (nonmetric) MDS. Possible are "primary" (default), "secondary" or "tertiary".}

\item{weightmat}{a matrix of finite weights.}

\item{init}{starting configuration}

\item{ndim}{dimension of the configuration; defaults to 2}

\item{acc}{numeric accuracy of the iteration. Default is 1e-6.}

\item{itmax}{maximum number of iterations. Default is 10000.}

\item{verbose}{should iteration output be printed; if > 1 then yes}

\item{principal}{If 'TRUE', principal axis transformation is applied to the final configuration}

\item{epochs}{for 'som_pcpla' it gives the number of passes through the data. The sequence of taus created is 'seq(tau,tau/epochs,length.out=epochs)'.}
}
\value{
a smacofP object (inheriting from smacofB, see \code{\link{smacofSym}}). It is a list with the components
\itemize{
\item delta: Observed, untransformed dissimilarities
\item tdelta: Observed explicitly transformed dissimilarities, normalized
\item dhat: Explicitly transformed dissimilarities (dhats), optimally scaled and normalized 
\item confdist: Configuration dissimilarities
\item conf: Matrix of fitted configuration
\item stress: Default stress  (stress 1; sqrt of explicitly normalized stress)
\item spp: Stress per point 
\item ndim: Number of dimensions
\item model: Name of smacof model
\item niter: Number of iterations
\item nobj: Number of objects
\item type: Type of MDS model
\item weightmat: weighting matrix as supplied
\item stress.m: Default stress (stress-1^2)
\item tweightmat: transformed weighting matrix; it is weightmat but containing all the 0s for the distances set to 0. 
}
}
\description{
An implementation of curvilinear component analysis by majorization with ratio, interval and ordinal optimal scaling for dissimilarities and power transformations for fitted distances. Note the neighborhood parameter tau is kept fixed here. See detials for how to use it as a self-organizing map.
}
\details{
If tau is too small it may happen that all distances for one i to all j are zero and then there will be an error, so make sure to set a larger tau.

We keep tau fixed throughout. In the orginal publication the idea was that of a self-organizing map which decreased tau over epochs (i.e., passes through the data). This can be achieved with our function by using a vector of decreasing tau values and calling the function with the first tau, then supplying the optimal configuration as the init for the next call with the next tau and so on. See the example.
}
\examples{
dis<-smacof::kinshipdelta
res<-pclca(as.matrix(dis),type="interval",kappa=2,tau=0.4,itmax=1000)
res
summary(res)
plot(res)

##which d_{ij}(X) exceeded tau at convergence (i.e., have been set to 0)?
res$tweighmat


\dontrun{
## Self-organizing map style (as in the original publication)
# Data 
datsen<-ProjectionBasedClustering::Hepta
dis<-dist(datsen$Data)

#run the som-style pclca 
sommod<-som_pclca(dis,tau=0.19,epochs=20,verbose=1)

#the clusters are clearly visible 
plot(sommod,col=datsen$Cls,cex=2,label.conf=list(label=FALSE))
}

}
\seealso{
\code{\link{smacofSym}}
}
