<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Thomas Rusch" />

<meta name="date" content="2023-01-12" />

<title>A Tutorial on Structure Optimized Proximity Scaling (STOPS)</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">A Tutorial on Structure Optimized Proximity
Scaling (STOPS)</h1>
<h4 class="author">Thomas Rusch</h4>
<h4 class="date">2023-01-12</h4>



<p>In this document we introduce the functionality available in
<code>stops</code> for fitting multidimensional scaling (MDS; Borg &amp;
Groenen 2005) or proximity scaling (PS) models either on their own or by
utilizing the STOPS idea. We start with a short introduction to PS and
the models that are available. We then explain fitting of these models
with the <code>stops</code> package. Next, we introduce the reader to
STOPS (Rusch, Mair &amp; Hornik, 2020; Rusch, Mair &amp; Hornik, 2023a),
a method to select hyperparameters in flexible mutlidimensional scaling
methods based on structures in the configuration. We show how to fit
those. We also mention P-COPS as a special case and show the connection
to COPS (Rusch, Mair &amp; Hornik, 2021). For illustration throughout
this document we use the <code>smacof::kinshipdelta</code> data set
(Rosenberg &amp; Kim, 1975) which lists percentages of how often 15
kinship terms were not grouped together by college students.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(stops)</span></code></pre></div>
<div id="proximity-scaling" class="section level2">
<h2>Proximity Scaling</h2>
<p>For proximity scaling (PS) or multidimensional scaling (MDS) the
input is typically an <span class="math inline">\(N\times N\)</span>
matrix <span class="math inline">\(\Delta^*=f(\Delta)\)</span>, a matrix
of proximities with elements <span class="math inline">\(\delta^*_{ij}\)</span>, that is a function of a
matrix of observed non-negative dissimilarities <span class="math inline">\(\Delta\)</span> with elements <span class="math inline">\(\delta_{ij}\)</span>. <span class="math inline">\(\Delta^*\)</span> usually is symmetric (but does
not need to be). The main diagonal of <span class="math inline">\(\Delta\)</span> is 0. We call a <span class="math inline">\(f: \delta_{ij} \mapsto \delta^*_{ij}\)</span> a
proximity transformation function. In the MDS literature these <span class="math inline">\(\delta_{ij}^*\)</span> are often called dhats or
disparities. The problem that proximity scaling solves is to locate an
<span class="math inline">\(N \times M\)</span> matrix <span class="math inline">\(X\)</span> (the configuration) with row vectors
<span class="math inline">\(x_i, i=1,\ldots,N\)</span> in
low-dimensional space <span class="math inline">\((\mathbb{R}^M, M \leq
N)\)</span> in such a way that transformations <span class="math inline">\(g(d_{ij}(X))\)</span> of the fitted distances
<span class="math inline">\(d_{ij}(X)=d(x_i,x_j)\)</span>—i.e., the
distance between different <span class="math inline">\(x_i,
x_j\)</span>—approximate the <span class="math inline">\(\delta^*_{ij}\)</span> as closely as possible. We
call a <span class="math inline">\(g: d_{ij}(X) \mapsto
d_{ij}^*(X)\)</span> a distance transformation function. In other words,
proximity scaling means finding <span class="math inline">\(X\)</span>
so that <span class="math inline">\(d^*_{ij}(X)=g(d_{ij}(X))\approx\delta^*_{ij}=f(\delta_{ij})\)</span>.
There may also be weights transformed weight <span class="math inline">\(w^*_{ij}=h(w_{ij})\)</span> with <span class="math inline">\(h: w_{ij} \mapsto w_{ij}^*\)</span> being a weight
transformation function.</p>
<p>This approximation <span class="math inline">\(D^*(X)\)</span> to the
matrix <span class="math inline">\(\Delta^*\)</span> is found by
defining a fit criterion (the loss function), <span class="math inline">\(\sigma_{PS}(X)=L(\Delta^*,D^*(X))\)</span>, that
is used to measure how closely <span class="math inline">\(D^*(X)\)</span> approximates <span class="math inline">\(\Delta^*\)</span>.</p>
<p>The loss function used is then minimized to find the vectors <span class="math inline">\(x_1,\dots,x_N\)</span>, i.e., <span class="math display">\[\begin{equation}
\label{eq:optim}
\arg \min_{X}\ \sigma_{PS}(X).
\end{equation}\]</span></p>
<div id="stress-models" class="section level3">
<h3>Stress Models</h3>
<p>The first popular type of PS supported in <code>stops</code> is based
on the loss function type <em>stress</em> (Kruskall 1964), employing a
quadratic loss function.</p>
<p>A general formulation of a loss function based on a quadratic loss is
<span class="math display">\[\begin{equation}
\label{eq:stress}
\sigma_{PS}(X)=\sigma_{stress}(X)=\sum^N_{i=1}\sum^N_{j=1}
w^*_{ij}\left[d^*_{ij}(X)-\delta^*_{ij}\right]^2=\sum^N_{i=1}\sum^N_{j=1}
h(w_{ij})\left[g\left(d_{ij}(X)\right)-f(\delta_{ij})\right]^2
\end{equation}\]</span> Here, the <span class="math inline">\(w_{ij}\)</span> are finite weights, with <span class="math inline">\(w_{ij}=0\)</span> if the entry is missing and
<span class="math inline">\(w_{ij}=1\)</span> otherwise. There are a
number of optimization techniques one can use to solve this optimization
problem.</p>
<p>The distances used is usually some type of Minkowski distance (<span class="math inline">\(p &gt; 0\)</span>) as the distance fitted to the
points in the configuration, <span class="math display">\[\begin{equation}
\label{eq:dist}
d_{ij}(X) = ||x_{i}-x_{j}||_p=\left( \sum_{m=1}^M |x_{im}-x_{jm}|^p
\right)^{1/p} \ i,j = 1, \dots, N.
\end{equation}\]</span> Typically, the norm used is the Euclidean norm,
so <span class="math inline">\(p=2\)</span>. In standard MDS <span class="math inline">\(g(\cdot)=f(\cdot)=I(\cdot)\)</span>, the identity
function.</p>
<p>This formulation enables one to express a large number of PS methods
many of which are implemented in <code>stops</code>. In
<code>stops</code> we allow to use specific choices for <span class="math inline">\(f(\cdot)\)</span>, <span class="math inline">\(g(\cdot)\)</span> and <span class="math inline">\(h(\cdot)\)</span> from the family of power
transformations so one can fit the following stress models:</p>
<ul>
<li><strong>Explicitly normalized stress</strong>: <span class="math inline">\(w^*_{ij}=(\sum_{ij}\delta^{*2}_{ij})^{-1}\)</span>,
<span class="math inline">\(\delta_{ij}^*=\delta_{ij}\)</span>, <span class="math inline">\(d^*_{ij}(X)=d_{ij}(X)\)</span></li>
<li><strong>Stress-1</strong>: <span class="math inline">\(w^*_{ij}=(\sum_{ij} d^{*2}_{ij}(X))^{-1}\)</span>,
<span class="math inline">\(\delta_{ij}^*=\delta_{ij}\)</span>, <span class="math inline">\(d_{ij}(X)^*=d_{ij}(X)\)</span></li>
<li><strong>Sammon stress</strong> (Sammon 1969): <span class="math inline">\(w^*_{ij}=\delta^{*-1}_{ij}\)</span> , <span class="math inline">\(\delta_{ij}^*=\delta_{ij}\)</span>, <span class="math inline">\(d_{ij}(X)^*=d_{ij}(X)\)</span></li>
<li><strong>Elastic scaling</strong> stress (McGee 1966): <span class="math inline">\(w_{ij}=\delta^{*-2}_{ij}\)</span>, <span class="math inline">\(\delta_{ij}^*=\delta_{ij}\)</span>, <span class="math inline">\(d_{ij}(X)^*=d_{ij}(X)\)</span></li>
<li><strong>S-stress</strong> (Takane et al. 1977): <span class="math inline">\(\delta^*_{ij}=\delta_{ij}^2\)</span> and <span class="math inline">\(d^*_{ij}(X)=d^2_{ij}(X)\)</span>, <span class="math inline">\(w^*_{ij}=1\)</span></li>
<li><strong>R-stress</strong> (de Leeuw, 2014): <span class="math inline">\(\delta^*_{ij}=\delta_{ij}\)</span> and <span class="math inline">\(d^*_{ij}=d^{2r}_{ij}\)</span>, <span class="math inline">\(w^*_{ij}=1\)</span></li>
<li><strong>Power MDS</strong> (Buja et al. 2008, Rusch, Mair &amp;
Hornik 2021): <span class="math inline">\(\delta^*_{ij}=\delta_{ij}^\lambda\)</span> and
<span class="math inline">\(d^*_{ij}=d^\kappa_{ij}\)</span>, <span class="math inline">\(w^*_{ij}=1\)</span></li>
<li><strong>Power elastic scaling</strong> (Rusch, Mair &amp; Hornik
2023): <span class="math inline">\(w^*_{ij}=\delta^{*-2}_{ij}\)</span>,
<span class="math inline">\(\delta^*_{ij}=\delta_{ij}^\lambda\)</span>
and <span class="math inline">\(d^*_{ij}=d^\kappa_{ij}\)</span></li>
<li><strong>Power Sammon mapping</strong> (Rusch, Mair &amp; Hornik
2023): <span class="math inline">\(w^*_{ij}=\delta^{*-1}_{ij}\)</span>,
<span class="math inline">\(\delta^*_{ij}=\delta_{ij}^\lambda\)</span>
and <span class="math inline">\(d^*_{ij}=d^\kappa_{ij}\)</span></li>
<li><strong>Restricted powerstress</strong> (Rusch, Mair &amp; Hornik,
2021): <span class="math inline">\(\delta^*_{ij}=\delta_{ij}^\lambda\)</span>, <span class="math inline">\(d^*_{ij}=d^\kappa_{ij}\)</span> but with the
restriction <span class="math inline">\(\kappa=\lambda\)</span>. The
<span class="math inline">\(w^*_{ij}=w_{ij}^\nu\)</span> for arbitrary
<span class="math inline">\(w_{ij}\)</span> (e.g., a function of the
<span class="math inline">\(\delta_{ij}\)</span>)</li>
<li><strong>Power stress</strong> (encompassing all previous models;
Buja et al. 2008, Rusch, Mair &amp; Hornik 2021): <span class="math inline">\(\delta^*_{ij}=\delta_{ij}^\lambda\)</span>, <span class="math inline">\(d^*_{ij}=d^\kappa_{ij}\)</span> and <span class="math inline">\(w^*_{ij}=w_{ij}^\nu\)</span> for arbitrary <span class="math inline">\(w_{ij}\)</span> (e.g., a function of the <span class="math inline">\(\delta_{ij}\)</span>)</li>
<li><strong>Approximate power stress</strong> (Rusch, Mair &amp; Hornik,
2021): This approximates power stress by <span class="math display">\[\begin{equation}
\label{eq:apstress}
\sigma_{PS}(X)+\sigma_{apstress}(X)=\sum_{i&lt;j} \delta_{ij}^\upsilon
\left(\delta_{ij}^\tau - d_{ij}(X)\right)^2
\end{equation}\]</span> where the relation to p-stress is so that <span class="math inline">\(\upsilon=\nu + 2\lambda(1 -1/\kappa)\)</span> and
<span class="math inline">\(\tau=\lambda/\kappa\)</span>. The
approximation of p-stress by ap-stress works well in cases when for the
<span class="math inline">\(x_i,x_j\)</span> for which <span class="math inline">\(w_{ij}\)</span> is large, the error <span class="math inline">\(\delta_{ij}^\lambda - d_{ij}(X)^\kappa\)</span> is
small, so that <span class="math inline">\(d_{ij}(X)^\kappa\)</span> is
approximated reasonably well by <span class="math inline">\(\delta_{ij}^\lambda\)</span> and, equivalently,
<span class="math inline">\(d_{ij}(X)^\kappa\)</span> can be
approximated well by <span class="math inline">\(d_{ij}(X)
\delta_{ij}^{(\lambda (\kappa-1)/\kappa)}\)</span>.</li>
<li><strong>Local MDS</strong> (LMDS; Chen &amp; Buja, 2009): Let <span class="math inline">\(N_k\)</span> define the symmetric set of nearby
pairs of points <span class="math inline">\((i,j)\)</span> so that <span class="math inline">\((i,j)\in N_k\)</span> iff <span class="math inline">\(i\)</span> is among the <span class="math inline">\(k-\)</span>nearest neighbours of <span class="math inline">\(j\)</span> or the other way round. Then we have a
stress model with <span class="math display">\[\begin{equation}
\delta^*_{ij}=\begin{cases}
\delta_{ij} &amp;\mbox{ if } (i,j) \in N_k\\
\sqrt{w}\delta_{\infty} &amp;\mbox{ if } (i,j) \in N_k\\
\end{cases}
\end{equation}\]</span> and <span class="math display">\[\begin{equation}
d^*_{ij}(X)=\begin{cases}
d_{ij}(X) &amp;\mbox{ if } (i,j) \in N_k\\
\sqrt{w}d_{ij}(X)  &amp;\mbox{ if } (i,j) \in N_k\\
\end{cases}
\end{equation}\]</span> where <span class="math inline">\(\delta_{\infty} \rightarrow \infty\)</span> is a
large ``imputed’’ dissimilarity that is constant and <span class="math inline">\(w\)</span> a small weight. For simplification, one
takes <span class="math inline">\(w \sim 1/\delta_{\infty}\)</span> in
the standard lMDS objective, so one uses the tuning parameter <span class="math inline">\(\tau=2w\delta_{\infty}\)</span> for given <span class="math inline">\(k\)</span>.</li>
</ul>
<p>For all of the above models but local MDS one can use the function
<code>powerStressMin</code> which uses majorization to find the solution
(De Leeuw, 2014) . The function allows to specify a <code>kappa</code>,
<code>lambda</code> and <code>nu</code> argument as well as a
<code>weightmat</code> (the <span class="math inline">\(w_{ij}\)</span>). LMDS can be fitted with the
<code>lmds</code> function. For approximate power stress there also is a
convenience function <code>apStressMin</code>.</p>
</div>
<div id="strain-models" class="section level3">
<h3>Strain Models</h3>
<p>The second popular type of PS supported in <code>stops</code> is
based on the loss function type . Here the <span class="math inline">\(\Delta^*\)</span> are a transformation of the
<span class="math inline">\(\Delta\)</span>, <span class="math inline">\(\Delta^*= f (\Delta)\)</span> so that <span class="math inline">\(f(\cdot)=-(h\circ l)(\cdot)\)</span> where <span class="math inline">\(l\)</span> is any function and <span class="math inline">\(h(\cdot)\)</span> is a double centering operation,
<span class="math inline">\(h(\Delta)=\Delta-\Delta_{i.}-\Delta_{.j}+\Delta_{..}\)</span>
where <span class="math inline">\(\Delta_{i.}, \Delta_{.j},
\Delta_{..}\)</span> are matrices consisting of the row, column and
grand marginal means respectively. These then get approximated by
(functions of) the inner product matrices of <span class="math inline">\(X\)</span> <span class="math display">\[\begin{equation}
\label{eq:dist2}
d_{ij}(X) = \langle x_{i},x_{j} \rangle
\end{equation}\]</span> We can thus express classical scaling as a
special case of the general PS loss with <span class="math inline">\(d_{ij}(X)\)</span> as an inner product, <span class="math inline">\(g(\cdot) = I(\cdot)\)</span> and <span class="math inline">\(f(\cdot)=-(h \circ I)(\cdot)\)</span>.</p>
<p>If we again allow power transformations for <span class="math inline">\(g(\cdot)\)</span> and <span class="math inline">\(f(\cdot)\)</span> one can fit the following strain
models with <code>stops</code></p>
<ul>
<li><strong>Classical scaling</strong> (Torgerson, 1958): <span class="math inline">\(\delta^*_{ij}=-h(\delta_{ij})\)</span> and <span class="math inline">\(d^*_{ij}=d_{ij}\)</span></li>
<li><strong>Powerstrain</strong> (Buja et al. 2008, Rusch, Mair &amp;
Hornik 2021): <span class="math inline">\(\delta^*_{ij}=-h(\delta_{ij}^\lambda)\)</span>,
<span class="math inline">\(d^*_{ij}=d_{ij}\)</span> and <span class="math inline">\(w_{ij}=w_{ij}^\nu\)</span> for arbitrary <span class="math inline">\(w_{ij}\)</span></li>
</ul>
<p>In <code>stops</code> we have a wrapper to <code>cmdscale</code>
(overloading the <code>base</code> function) which extend functionality
by offering an object that matches <code>smacofP</code> objects with
corresponding methods.</p>
</div>
<div id="energy-models" class="section level3">
<h3>Energy Models</h3>
<p>The third type of PS supported in <code>stops</code> is based on the
energy type losses of pairwise attraction and repulsion between objects
(Chen &amp; Buja, 2014, Rusch, Mair, Hornik 2023a). It is related to
graph drawing: if vertices are equated with objects, the edge weights
are the <span class="math inline">\(\delta^*_{ij}\)</span>, the node
positions in the layout is the <span class="math inline">\(X\)</span>
and the distance between nodes in the layout are <span class="math inline">\(d_{ij}(X)\)</span>.</p>
<p>One can express badness-of-fit as comprising a repulsion part <span class="math inline">\(\propto -\delta^*_{ij}d^*_{ij}(X)\)</span> and an
attraction part <span class="math inline">\(\propto
d^{*\mu}_{ij}(X)\)</span> (Chen &amp; Buja, 2014). This is<br />
<span class="math display">\[\begin{equation}
\label{eq:energy}
\sigma_{PS}(X)=\sigma_{EM}(X) = \sum_{i&lt;j} w^*_{ij} \left(a
d^{*\mu}_{ij}(X) -  b \delta^*_{ij}d^*_{ij}(X) \right)
\end{equation}\]</span> with <span class="math inline">\(a,b\)</span>
being constants and <span class="math inline">\(d^*_{ij}(X)=g(d_{ij}(X))\)</span> and <span class="math inline">\(\delta^*_{ij}=f(d_{ij}(X))\)</span>. For <span class="math inline">\(\mu=2, a=1\)</span> and <span class="math inline">\(b=2\)</span> this is a stress model where terms
depending solely on <span class="math inline">\(\delta^*_{ij}\)</span>
are disregarded for finding <span class="math inline">\(X\)</span>.</p>
<p>Specific instances of energy models that can be fitted in
<code>stops</code> are:</p>
<ul>
<li><strong>Box-Cox MDS</strong> (Chen &amp; Buja, 2014). This is a
three-parameter family <span class="math inline">\(\theta=(\mu^{(BC)},\lambda^{(BC)},\rho^{(BC)})^\top\)</span>:
<span class="math display">\[\begin{equation}
\label{eq:bcstress}
\sigma_{PS}(X)=\sigma_{BCstress}(X) = \sum_{i&lt;j} \delta_{ij}^{\rho}
\left( BC_{\mu+\lambda}(d_{ij}(X)) - \delta_{ij}^{\lambda}
BC_{\mu}(d_{ij}(X)) \right)
\end{equation}\]</span> with <span class="math inline">\(\mu, \rho\in
\mathbb{R}\)</span> and <span class="math inline">\(\lambda \in
\mathbb{R}_+\)</span>. Here <span class="math inline">\(BC_\alpha\)</span> is the one-parameter Box-Cox
transformation with parameter <span class="math inline">\(\alpha\)</span>, <span class="math display">\[\begin{equation}
\label{eq:bc}
BC_{\alpha}(d)=\begin{cases}
  \frac{d^{\alpha}-1}{\alpha} \mbox{ if } \alpha \neq 0\\
  \log(d)  \mbox{ if } \alpha = 0\\
\end{cases}
\end{equation}\]</span> For <span class="math inline">\(w_{ij}=\delta_{ij}, \mu=\lambda=1\)</span> this is
very similar to the stress-equivalent energy MDS model. Note that here
the distance transformation functions in the attraction and repulsion
parts need not be equal. <span class="math inline">\(\sigma_{\text{BC}}(X)\)</span> shares close
similarities with stress with power transformations (power stress): They
will often lead to a similar configurations for the same parameters
(even equivalent if the exponents for repulsion and attraction parts are
the same).</li>
</ul>
</div>
<div id="usage-of-flexible-mds-models" class="section level3">
<h3>Usage of flexible MDS models</h3>
<p>The objects returned from <code>powerStressMin</code>,
<code>lmds</code>, <code>bcStressMin</code> and <code>apStressMin</code>
inherit from class <code>smacofP</code> which extends the
<code>smacof</code> classes (De Leeuw &amp; Mair, 2009) to allow for the
transformations. Apart from that all the objects are made so that they
are compatible to methods from <code>smacof</code> and also inherit from
<code>smacof</code>. Accordingly, the following S3 methods are
available:</p>
<table>
<thead>
<tr class="header">
<th align="left">Method</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">print</td>
<td align="left">Prints the object</td>
</tr>
<tr class="even">
<td align="left">summary</td>
<td align="left">A summary of the object</td>
</tr>
<tr class="odd">
<td align="left">plot</td>
<td align="left">2D Plots of the object</td>
</tr>
<tr class="even">
<td align="left">plot3d</td>
<td align="left">Dynamic 3D configuration plot</td>
</tr>
<tr class="odd">
<td align="left">plot3dstatic</td>
<td align="left">Static 3D configuration plot</td>
</tr>
<tr class="even">
<td align="left">residuals</td>
<td align="left">Residuals</td>
</tr>
<tr class="odd">
<td align="left">coef</td>
<td align="left">Model Coefficients</td>
</tr>
</tbody>
</table>
<p>Let us illustrate the usage.</p>
<p>First we setup our dissimilarity matrix <span class="math inline">\([\delta_{ij}]\)</span> and call it
<code>dis</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>dis<span class="ot">&lt;-</span><span class="fu">as.matrix</span>(smacof<span class="sc">::</span>kinshipdelta)</span></code></pre></div>
<p>We now fit a series of MDS models available in
<code>stops</code>.</p>
<ul>
<li>A standard MDS (<code>stress</code>)</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>res1<span class="ot">&lt;-</span><span class="fu">powerStressMin</span>(dis,<span class="at">kappa=</span><span class="dv">1</span>,<span class="at">lambda=</span><span class="dv">1</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>res1</span></code></pre></div>
<pre><code>## 
## Call:
## powerStressMin(delta = dis, kappa = 1, lambda = 1)
## 
## Model: Power Stress SMACOF 
## Number of objects: 15 
## Stress-1 value: 0.264 
## Number of iterations: 5352</code></pre>
<ul>
<li>A <code>sammon</code> mapping</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>res2<span class="ot">&lt;-</span><span class="fu">powerStressMin</span>(dis,<span class="at">kappa=</span><span class="dv">1</span>,<span class="at">lambda=</span><span class="dv">1</span>,<span class="at">nu=</span><span class="sc">-</span><span class="dv">1</span>,<span class="at">weightmat=</span>dis)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>res2</span></code></pre></div>
<pre><code>## 
## Call:
## powerStressMin(delta = dis, kappa = 1, lambda = 1, nu = -1, weightmat = dis)
## 
## Model: Power Stress SMACOF 
## Number of objects: 15 
## Stress-1 value: 0.289 
## Number of iterations: 81666</code></pre>
<p>Alternatively, one can use the faster <code>sammon</code> function
from <code>MASS</code> (Venables &amp; Ripley, 2002) for which we
provide a wrapper that adds class attributes and methods (and overloads
the function).</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>res2a<span class="ot">&lt;-</span><span class="fu">sammon</span>(dis)</span></code></pre></div>
<pre><code>## Initial stress        : 0.17053
## stress after   3 iters: 0.10649</code></pre>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>res2a</span></code></pre></div>
<pre><code>## 
## Call: sammon(d = dis)
## 
## Model: Sammon Scaling 
## Number of objects: 15 
## Stress: 0.1064925</code></pre>
<ul>
<li>An <code>elastic</code> scaling</li>
</ul>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>res3<span class="ot">&lt;-</span><span class="fu">powerStressMin</span>(dis,<span class="at">kappa=</span><span class="dv">1</span>,<span class="at">lambda=</span><span class="dv">1</span>,<span class="at">nu=</span><span class="sc">-</span><span class="dv">2</span>,<span class="at">weightmat=</span>dis)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>res3</span></code></pre></div>
<pre><code>## 
## Call:
## powerStressMin(delta = dis, kappa = 1, lambda = 1, nu = -2, weightmat = dis)
## 
## Model: Power Stress SMACOF 
## Number of objects: 15 
## Stress-1 value: 0.305 
## Number of iterations: 1e+05</code></pre>
<ul>
<li>A <code>sstress</code> model</li>
</ul>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>res4<span class="ot">&lt;-</span><span class="fu">powerStressMin</span>(dis,<span class="at">kappa=</span><span class="dv">2</span>,<span class="at">lambda=</span><span class="dv">2</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>res4</span></code></pre></div>
<pre><code>## 
## Call:
## powerStressMin(delta = dis, kappa = 2, lambda = 2)
## 
## Model: Power Stress SMACOF 
## Number of objects: 15 
## Stress-1 value: 0.346 
## Number of iterations: 47130</code></pre>
<ul>
<li>An <code>rstress</code> model (with <span class="math inline">\(r=1\)</span> as <span class="math inline">\(r=\kappa/2\)</span>)</li>
</ul>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>res5<span class="ot">&lt;-</span><span class="fu">powerStressMin</span>(dis,<span class="at">kappa=</span><span class="dv">2</span>,<span class="at">lambda=</span><span class="dv">1</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>res5</span></code></pre></div>
<pre><code>## 
## Call:
## powerStressMin(delta = dis, kappa = 2, lambda = 1)
## 
## Model: Power Stress SMACOF 
## Number of objects: 15 
## Stress-1 value: 0.404 
## Number of iterations: 21201</code></pre>
<ul>
<li>A <code>powermds</code> model (i.e., <span class="math inline">\(\nu=1\)</span>)</li>
</ul>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>res6<span class="ot">&lt;-</span><span class="fu">powerStressMin</span>(dis,<span class="at">kappa=</span><span class="dv">2</span>,<span class="at">lambda=</span><span class="fl">1.5</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>res6</span></code></pre></div>
<pre><code>## 
## Call:
## powerStressMin(delta = dis, kappa = 2, lambda = 1.5)
## 
## Model: Power Stress SMACOF 
## Number of objects: 15 
## Stress-1 value: 0.367 
## Number of iterations: 50564</code></pre>
<ul>
<li>A <code>powersammon</code> model</li>
</ul>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>res7<span class="ot">&lt;-</span><span class="fu">powerStressMin</span>(dis,<span class="at">kappa=</span><span class="dv">2</span>,<span class="at">lambda=</span><span class="fl">1.5</span>,<span class="at">nu=</span><span class="sc">-</span><span class="dv">1</span>,<span class="at">weightmat=</span>dis)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>res7</span></code></pre></div>
<pre><code>## 
## Call:
## powerStressMin(delta = dis, kappa = 2, lambda = 1.5, nu = -1, 
##     weightmat = dis)
## 
## Model: Power Stress SMACOF 
## Number of objects: 15 
## Stress-1 value: 0.436 
## Number of iterations: 1e+05</code></pre>
<ul>
<li>A <code>powerelastic</code> scaling</li>
</ul>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>res8<span class="ot">&lt;-</span><span class="fu">powerStressMin</span>(dis,<span class="at">kappa=</span><span class="dv">2</span>,<span class="at">lambda=</span><span class="fl">1.5</span>,<span class="at">nu=</span><span class="sc">-</span><span class="dv">2</span>,<span class="at">weightmat=</span>dis)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>res8</span></code></pre></div>
<pre><code>## 
## Call:
## powerStressMin(delta = dis, kappa = 2, lambda = 1.5, nu = -2, 
##     weightmat = dis)
## 
## Model: Power Stress SMACOF 
## Number of objects: 15 
## Stress-1 value: 0.519 
## Number of iterations: 1e+05</code></pre>
<ul>
<li>A <code>powerstress</code> model</li>
</ul>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>res9<span class="ot">&lt;-</span><span class="fu">powerStressMin</span>(dis,<span class="at">kappa=</span><span class="dv">2</span>,<span class="at">lambda=</span><span class="fl">1.5</span>,<span class="at">nu=</span><span class="sc">-</span><span class="fl">1.5</span>,<span class="at">weightmat=</span><span class="dv">2</span><span class="sc">*</span><span class="dv">1</span><span class="sc">-</span><span class="fu">diag</span>(<span class="fu">nrow</span>(dis)))</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>res9</span></code></pre></div>
<pre><code>## 
## Call:
## powerStressMin(delta = dis, kappa = 2, lambda = 1.5, nu = -1.5, 
##     weightmat = 2 * 1 - diag(nrow(dis)))
## 
## Model: Power Stress SMACOF 
## Number of objects: 15 
## Stress-1 value: 0.367 
## Number of iterations: 57237</code></pre>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(res9)</span></code></pre></div>
<pre><code>## 
## Configurations:
##                    D1      D2
## Aunt          -0.1225  0.2498
## Brother        0.1964 -0.1400
## Cousin         0.0525  0.3099
## Daughter      -0.2050 -0.1256
## Father         0.1639 -0.1822
## Granddaughter -0.2358 -0.0531
## Grandfather    0.2146 -0.1336
## Grandmother   -0.2360 -0.0868
## Grandson       0.2147 -0.1079
## Mother        -0.2098 -0.1363
## Nephew         0.1707  0.2110
## Niece         -0.1231  0.2442
## Sister        -0.2219 -0.0967
## Son            0.1702 -0.1707
## Uncle          0.1710  0.2181
## 
## 
## Stress per point:
##                  SPP SPP(%)
## Niece         0.0008 4.6861
## Nephew        0.0008 4.7097
## Aunt          0.0008 4.9367
## Uncle         0.0008 5.0269
## Daughter      0.0010 6.0875
## Son           0.0010 6.2785
## Father        0.0011 6.4569
## Mother        0.0011 6.6921
## Cousin        0.0011 6.8096
## Sister        0.0012 7.2765
## Brother       0.0012 7.2882
## Grandson      0.0013 7.9701
## Granddaughter 0.0013 8.0950
## Grandmother   0.0015 8.8103
## Grandfather   0.0015 8.8761</code></pre>
<ul>
<li>An <code>lmds</code> model</li>
</ul>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>res10<span class="ot">&lt;-</span><span class="fu">lmds</span>(dis,<span class="at">tau=</span><span class="fl">0.5</span>,<span class="at">k=</span><span class="dv">3</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>res10</span></code></pre></div>
<pre><code>## 
## Call:
## lmds(delta = dis, k = 3, tau = 0.5)
## 
## Model: Local MDS 
## Number of objects: 15 
## Stress-1 value: 0.302 
## Number of iterations: 80</code></pre>
<ul>
<li>An <code>apstress</code> model (approximate power stress)</li>
</ul>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>res11<span class="ot">&lt;-</span><span class="fu">apStressMin</span>(dis,<span class="at">tau=</span><span class="fl">0.5</span>,<span class="at">ups=</span><span class="dv">2</span>)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>res11</span></code></pre></div>
<pre><code>## 
## Call:
## apStressMin(delta = dis, tau = 0.5, ups = 2)
## 
## Model: Approximate Power Stress SMACOF 
## Number of objects: 15 
## Stress-1 value: 0.217 
## Number of iterations: 16</code></pre>
<p>We can visualize the obtained configurations with plot. For
<code>smacofP</code> objects we have the following plots.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(res9)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(res9,<span class="st">&quot;transplot&quot;</span>)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(res9,<span class="st">&quot;Shepard&quot;</span>)</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(res9,<span class="st">&quot;resplot&quot;</span>)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(res9,<span class="st">&quot;bubbleplot&quot;</span>)</span></code></pre></div>
<ul>
<li><code>powerstrain</code> model is rather easy to fit with simply
subjecting the dissimilarity matrix to some power. Here we use <span class="math inline">\(\lambda=3\)</span>.</li>
</ul>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>resc<span class="ot">&lt;-</span><span class="fu">cmdscale</span>(kinshipdelta<span class="sc">^</span><span class="dv">3</span>)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>resc</span></code></pre></div>
<pre><code>## 
## Call: cmdscale(d = kinshipdelta^3)
## 
## Model: Torgerson-Gower Scaling 
## Number of objects: 15 
## GOF: 0.4257747 0.6281985</code></pre>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(resc)</span></code></pre></div>
<pre><code>## 
## Configurations:
##                       D1         D2
## Aunt           178193.10  204986.70
## Brother       -174369.39  -94357.29
## Cousin         -48355.46  265057.17
## Daughter       169149.17 -109936.27
## Father        -145389.13 -168604.23
## Granddaughter  187039.12  -44850.80
## Grandfather   -180116.08 -103668.07
## Grandmother    199145.19  -83038.71
## Grandson      -169767.75  -72358.82
## Mother         185797.71 -138677.31
## Nephew        -195963.98  173123.81
## Niece          168278.13  208870.31
## Sister         182224.16  -70764.01
## Son           -149876.11 -135883.18
## Uncle         -205988.70  170100.68</code></pre>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(resc)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(resc)</span></code></pre></div>
<ul>
<li>A BC MDS with the <code>bcStressMin</code></li>
</ul>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>resbc<span class="ot">&lt;-</span><span class="fu">bcStressMin</span>(dis,<span class="at">mu=</span><span class="dv">3</span>,<span class="at">lambda=</span><span class="dv">2</span>,<span class="at">nu=</span><span class="dv">2</span>)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>resbc</span></code></pre></div>
<pre><code>## 
## Call:
## bcStressMin(delta = dis, mu = 3, lambda = 2, nu = 2)
## 
## Model: Box-Cox Stress MDS 
## Number of objects: 15 
## Stress-1 value: 0.251 
## Number of iterations: 67</code></pre>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(resbc)</span></code></pre></div>
</div>
</div>
<div id="selecting-hyperparameters-by-structure-considerations-stops" class="section level2">
<h2>Selecting Hyperparameters by Structure Considerations: STOPS</h2>
<p>We saw that these flexible models from above ( <em>power stress</em>,
<em>power strain</em>, <em>approximate power stress</em>, <em>local
MDS</em>, <em>Box-Cox MDS</em> and their variants) all have
hyperparameters <span class="math inline">\(\theta\)</span>; for
example, the hyperparameter vector for power stress is <span class="math inline">\(\theta=(\kappa,\lambda\nu)\)</span>. That begs the
question which hyperparameters should be chosenas the chosen values have
a huge impact on how the final configuration looks like (clearly a <span class="math inline">\(kappa=2\)</span> will lead to a different
configuration than <span class="math inline">\(\kappa=0.5\)</span>). So
far, we have simply assumed the analyst knows the “right” <span class="math inline">\(\theta\)</span>; indeed often (and as we did so
far) they are simply chosen ad hoc.</p>
<p>The main contribution of the <code>stops</code> package is not solely
in fitting the flexible MDS models for given <span class="math inline">\(\theta\)</span>. The idea behind STOPS is to also
allow to automatically select good hyperparameters <span class="math inline">\(\theta^*\)</span> to achieve a “structured” MDS
configuration. This can be useful in a variety of contexts: to explore
or generate structures, to restrict the target space, to avoid
artifacts, to preserve certain types of structures and so forth.</p>
<p>For this, the flexible MDS loss functions as described above are
augmented to include penalties for the type of structures one is aiming
for. This combination of an MDS loss with a structuredness penalty is
what we call “structure optimized loss” (stoploss) and the resulting
method is coined “Structured Optimized Proximity Scaling” (or STOPS,
Rusch, Mair &amp; Hornik, 2023a). STOPS is related to “Cluster Optimized
Proximity Scaling” (COPS; Rusch, Mair &amp; Hornik, 2021) which allows
to select optimal parameters so that the clusteredness appearance of the
configuation is improved (see below).</p>
<div id="model" class="section level3">
<h3>Model</h3>
<p>Following Rusch, Mair &amp; Hornik (2023a) the general idea is that
from given observations <span class="math inline">\(\Delta\)</span> we
look for a configuration <span class="math inline">\(X\)</span>. The
<span class="math inline">\(X\)</span> has properties with regards to
its structural appearance, which we call <em>c-structuredness</em> for
configuration-structuredness. There are different types of
c-structuredness people might be interested in (say, how clustered the
result is, or that dimensions are orthogonal or if there is some
submanifold that the data live on). We developed indices for these types
of c-structuredness that capture that essence in the configuration (see
Rusch, Mair &amp; Hornik 2023b, or Rusch, Mair &amp; Hornik 2020 for a
large list of structures and indices).</p>
<p>We have as part of a STOPS model a proximity scaling loss function
<span class="math inline">\(\sigma_{PS}(\cdot)\)</span> and some
transformation <span class="math inline">\(f_{ij}(\delta_{ij}|\theta_f)\)</span> and <span class="math inline">\(g_{ij}(d_{ij}|\theta_g)\)</span> and possibly
<span class="math inline">\(h_{ij}(w_{ij}|\theta_h)\)</span>. These
functions are parametrized and all parameters are collected in the
vector <span class="math inline">\(\theta=(\theta_f,\theta_g,\theta_h)\)</span>.
<span class="math inline">\(\theta\)</span> is finite, e.g., a
transformation applied to all observations like a power transformation.
For example for power stress <span class="math inline">\(\theta=(\kappa,\lambda\nu)\)</span> and for Box
Cox MDS it is <span class="math inline">\(\theta=(\mu,\lambda,\rho)\)</span>. These
transformations achieve a sort of push towards more structure, so
different values for <span class="math inline">\(\theta\)</span> will in
general lead to different c-structuredness.</p>
<p>Let us assume we are interested in <span class="math inline">\(L\)</span> different structural qualities of <span class="math inline">\(X\)</span> and that we have <span class="math inline">\(L\)</span> corresponding univariate
c-structuredness indices <span class="math inline">\(I_l(X\vert
\gamma)\)</span> for the <span class="math inline">\(l=1,\dots,
L\)</span> different structures, capturing the essence of the structural
appearance of the configuration with respect to the <span class="math inline">\(l\)</span>-th structure. For example, we might be
interested in both the structural appearance of how clustered the
configuration is (structure 1) and how strongly linearly related the
column vectors of the configuration are (structure 2). We then measure
the c-structuredness of <span class="math inline">\(X\)</span> for the
two structures with an index for clusteredness and one for linear
dependence respectively. The <span class="math inline">\(\gamma\)</span>
are optional metaparameters for the indices, which we assume are given
and fixed; they control how c-structuredness is measured. We further
assume broadly that the transformations <span class="math inline">\(f(\Delta\vert\theta_f)\)</span> and/or <span class="math inline">\(g(D(X)\vert \theta_g)\)</span> and/or <span class="math inline">\(h(W\vert \theta_h)\)</span> produce different
c-structuredness in <span class="math inline">\(X\)</span> for different
values of <span class="math inline">\(\theta\)</span>.</p>
<p>In a nutshell our proposal is to select optimal hyperparameters <span class="math inline">\(\theta^\ast\)</span> for the scaling procedure by
assessing the c-structuredness of an optimal configuration <span class="math inline">\(X^\ast\)</span> found from a PS method for given
<span class="math inline">\(\theta\)</span> usually in combination with
its badness-of-fit value. We aim at finding a <span class="math inline">\(\theta^\ast\)</span> that, when used as
transformation parameters in the PS method, will give a configuration
that has high (or low) values of the c-structuredness indices. We view
this as a multi-objective optimization problem, where we want to
maximize/minimize different criteria (either badness-of-fit, or
c-structuredness, or both) over <span class="math inline">\(\theta\)</span>. C-structuredness may this way be
induced at a possible expense of fit but we control the expense
amount.</p>
<p>To formalize this we explicitly write the building blocks of the
objective function used for hyperparameter tuning via STOPS as a
function of <span class="math inline">\(\theta\)</span>: Let us denote
by <span class="math inline">\(X^\ast(\theta)\)</span> the optimal
solution from minimizing a badness-of-fit <span class="math inline">\(\sigma_{PS}(X \vert \theta)\)</span> for a fixed
<span class="math inline">\(\theta\)</span>, so <span class="math inline">\(X^\ast(\theta):= \arg\min_{X} \sigma_{PS}(X\vert
\theta)\)</span>. Further we also have the <span class="math inline">\(L\)</span> different univariate indices with
possible metaparameters <span class="math inline">\(\bm\gamma\)</span>,
<span class="math inline">\(I_l(X^\ast(\theta)\vert \gamma)\)</span> to
be optimized for.</p>
<p>Specific variants of STOPS can be instantiated by defining objective
functions <span class="math inline">\(\text{Stoploss}(\theta\vert v_0,
\dots, v_L, \gamma)\)</span>, comprising either badness-of-fit or
c-structuredness indices or both in a scalarized combination. Two
variants of objective functions—called additive STOPS (aSTOPS) and
multiplicative STOPS (mSTOPS) respectively—are of the following form:
<span class="math display">\[\begin{align}
\label{eq:astops}
\text{Stoploss}_{aSTOPS}(\theta\vert v_0, \dots, v_L, \gamma) = v_0
\cdot \sigma_{PS}(X^\ast(\theta)\vert\theta) + \sum^L_{l=1} v_l
I_l(X^\ast(\theta)\vert \gamma)
\end{align}\]</span> and <span class="math display">\[\begin{align}
\label{eq:mstops}
\text{Stoploss}_{mSTOPS}(\theta \vert v_0, \dots, v_L, \gamma) =
\sigma_{PS}(X^\ast(\theta)\vert \theta)^{v_0} \cdot \prod^L_{l=1}
I_l(X}^\ast(\theta)\vert\gamma)^{v_l}
\end{align}\]</span> with <span class="math inline">\(v_0 \in
\mathbb{R}_{\geq 0}\)</span> and <span class="math inline">\(v_1,\dots,v_L \in \mathbb{R}\)</span> being the
scalarization weights that determine how the individual parts (MDS loss
and c-structuredness indices) are aggregated. Note that in this
formulation the aggregation is a sum/product, so the weights must be
negative if a higher index stands for more structure and we want more of
that structure. Alternatively, the <code>stressweight</code> can be
negative and the <code>strucweight</code> positive.</p>
<p>Numerically, the badness-of-fit function value <span class="math inline">\(\sigma_{PS}(X^\ast(\theta)\vert \theta)\)</span>
needs to be normalized to be scale-free and commensurable for
comparability of different values of <span class="math inline">\(\theta\)</span>. The objective function for aSTOPS
is fully compensatory, whereas for mSTOPS it ensures that a normalized
badness-of-fit of <span class="math inline">\(0\)</span> will always
lead to the minimal <span class="math inline">\(\text{Stoploss}(\theta\vert v_0, \dots, v_L,
\gamma)\)</span> for a positive value of <span class="math inline">\(I_l(\cdot)\)</span>. For notational convenience,
we will refer to the objective functions for STOPS variants by <span class="math inline">\(\text{Stoploss}(\theta)\)</span> from now on.</p>
<p>The job is then to find <span class="math display">\[\begin{equation}  
\arg\min_{\theta}\ \text{Stoploss}(\theta)
\end{equation}\]</span></p>
<p>Minimizing stoploss can be quite difficult. In <code>stops</code> we
use a nested algorithm combining optimization that internally first
solves for <span class="math inline">\(X\)</span> given <span class="math inline">\(\theta\)</span>, <span class="math inline">\(\arg\min_X
\sigma_{PS}\left(X|\theta\right)\)</span> in an inner loop, and then
optimize over <span class="math inline">\(\theta\)</span> with a
metaheuristic in an outer loop. The number of iterations of the outer
loop can be controlled with <code>itmax</code>, the number of iterations
of the inner loop with <code>itmaxps</code>.</p>
<div id="optimization" class="section level4">
<h4>Optimization</h4>
<p>Implemented metaheuristics are simulated annealing
(<code>optimmethod=&quot;SANN&quot;</code>), particle swarm optimization
(<code>optimmethod=&quot;pso&quot;</code>), DIRECT
(<code>optimmethod=&quot;DIRECT&quot;</code>), stochastic global optimization
(<code>optimmethod=&quot;stogo&quot;</code>), COBYLA
(<code>optimmethod=&quot;cobyla&quot;</code>), Controlled Random Search 2 with
local mutation (<code>optimmethod=&quot;crs2lm&quot;</code>), Improved Stochastic
Ranking Evolution Strategy (<code>optimmethod=&quot;isres&quot;</code>),
Multi-Level Single-Linkage (<code>optimmethod=&quot;mlsl&quot;</code>),
Nelder-Mead (<code>optimmethod=&quot;neldermead&quot;</code>), Subplex
(<code>optimmethod=&quot;sbplx&quot;</code>), Hooke-Jeeves Pattern Search
(<code>optimmethod=&quot;hjk&quot;</code>), CMA-ES
(<code>optimmethod=&quot;cmaes&quot;</code>), Bayesian optimization with Gaussian
Process priors and Kriging (<code>optimmethod=&quot;Kriging&quot;</code>),
Bayesian optimization with treed Gaussian processes with jump to linear
models (<code>optimmethod=&quot;tgp&quot;</code>) and Adaptive Luus-Jaakola Search
(<code>optimmethod=&quot;ALJ&quot;</code>). Defaults is “ALJ”.</p>
<p>So there are a lot of solvers to choose from. In our experience
<code>tgp</code>, <code>ALJ</code>, <code>Kriging</code> and
<code>pso</code> usually work reasonably well for relatively low values
of <code>itmax</code>, the iterations of the outer loop (up to 20). If
the data are small, then <code>ALJ</code> and <code>pso</code> (with s=5
particles) and with relatively high <code>itmax</code> (&gt;50) is
typically good. If the data are larger (so that solving the PS problem
is becoming very costly) we want to minimize the number of outer
iterations and then Bayesian optimization with <code>tgp</code> or
<code>Kriging</code> is typically good for <code>itmax</code> of about
<span class="math inline">\(10\)</span>. The return of <code>tgp</code>
is diminishing for higher <code>itmax</code>, so if a higher number of
<code>itmax</code> can be afforded <code>pso</code> is often better and
more efficient.</p>
</div>
<div id="c-structuredness" class="section level4">
<h4>C-Structuredness</h4>
<p>Currently the following c-structuredness types are supported:</p>
<ul>
<li><strong>c-clusteredness</strong> (<code>cclusteredness</code>): A
clustered appearance of the configuration (<span class="math inline">\(I_k\)</span> is the normed OPTICS cordillera
(COPS; Rusch et al. 2015a); 0 means no c-clusteredness, 1 means perfect
c-clusteredness)</li>
<li><strong>c-linearity</strong> (<code>clinearity</code>): Projections
lie close to a linear subspace of the configuration (<span class="math inline">\(I_k\)</span> is maximal multiple correlation; 0
means orthogonal, 1 means perfectly linear)</li>
<li><strong>c-manifoldness</strong> (<code>cmanifoldness</code>):
Projections lie on a sub manifold of the configuration (<span class="math inline">\(I_k\)</span> is maximal correlation (Sarmanov,
1958); only available for two dimensions; 1 means perfectly smooth
function)</li>
<li><strong>c-dependence</strong> (<code>cdependence</code>): Random
vectors of projections onto the axes are stochastically dependent (<span class="math inline">\(I_k\)</span> is distance correlation (Szekely et
al., 2007); only available for two dimensions; 0 means they are
stochastically independent)</li>
<li><strong>c-association</strong> (<code>cassociation</code>): Pairwise
nonlinear association between dimensions (<span class="math inline">\(I_k\)</span> is the pairwise maximal maximum
information coefficient (Reshef et al. 2011), 1 means perfect functional
association)<br />
</li>
<li><strong>c-nonmonotonicity</strong> (<code>cnonmonotonicity</code>):
Deviation from monotonicity (<span class="math inline">\(I_k\)</span> is
the pairwise maximal maximum assymmetry score (Reshef et al. 2011), the
higher the less monotone)<br />
</li>
<li><strong>c-functionality</strong> (<code>cfunctionality</code>):
Pairwise functional, smooth, noise-free relationship between dimensions
(<span class="math inline">\(I_k\)</span> is the mean pairwise maximum
edge value (Reshef et al. 2011), 1 means perfect functional
association)</li>
<li><strong>c-complexity</strong> (<code>ccomplexity</code>): Measures
the degree of complexity of the functional relationship between any two
dimensions (<span class="math inline">\(I_k\)</span> is the pairwise
maximal minimum cell number (Reshef et al. 2011), the higher the more
complex)</li>
<li><strong>c-faithfulness</strong> (<code>cfaithfulness</code>): How
accurate is the neighbourhood of <span class="math inline">\(\Delta\)</span> preserved in <span class="math inline">\(D\)</span> (<span class="math inline">\(I_k\)</span> is the adjusted Md index of Chen
&amp; Buja, 2013; note that this index deviates from the others by being
a function of both <span class="math inline">\(X^*\)</span> and <span class="math inline">\(\Delta^*\)</span> rather than <span class="math inline">\(X^*\)</span> alone)</li>
<li><strong>c-regularity</strong> (<code>cregularity</code>): How
regular are the objects arranged.</li>
<li><strong>c-hierarchy</strong> (<code>chierachy</code>): Captures how
well a partition/ultrametric (obtained by hclust) explains the
configuration distances.</li>
<li><strong>c-convexity</strong> (<code>cconvexity</code>): Measures how
convex the object arrangement is.</li>
<li><strong>c-striatedness</strong> (<code>cstriatedness</code>):
Measures how striated the object arrangement is.</li>
<li><strong>c-outlying</strong> (<code>coutlying</code>): Measures if
there are many outlying points.</li>
<li><strong>c-skinniness</strong> (<code>cskinniness</code>): Measures
how skinny the object arrangement is.<br />
</li>
<li><strong>c-sparsity</strong> (<code>csparsity</code>): Measures how
sparse the object arrangement is.</li>
<li><strong>c-stringiness</strong> (<code>cstringiness</code>): Measures
how stringy the object arrangement is.</li>
<li><strong>c-clumpiness</strong> (<code>cclumpiness</code>): Measures
how clumpy the object arrangement is.</li>
<li><strong>c-inequality</strong> (<code>cinequlaity</code>): Measures
how unequal the object arrangement is (as it is the Pearson coefficient
of variation)</li>
</ul>
<p>See Rusch, Mair, Hornik (2020) or Rusch, Mair, Hornik (2023b) for a
precise definition of each c-structuredness index.</p>
<p>One can also call each index with the function <code>c_foo</code>
where foo stands for the structure, so
e.g. <code>c_stringiness(X)</code> will give the value of c-stringiness
for object <code>X</code>. Note that the c-structuredness functions may
have additional metaparameters. For example:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>X<span class="ot">&lt;-</span>res9<span class="sc">$</span>conf</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="fu">c_stringiness</span>(X)</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="fu">c_clumpiness</span>(X)</span></code></pre></div>
<pre><code>## [1] 0.5944404</code></pre>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="fu">c_association</span>(X,<span class="at">alpha=</span><span class="fl">0.7</span>,<span class="at">C=</span><span class="dv">10</span>)</span></code></pre></div>
<pre><code>## [1] 0.4370104</code></pre>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="fu">c_clusteredness</span>(X,<span class="at">minpts=</span><span class="dv">3</span>)</span></code></pre></div>
<pre><code>## [1] 0.5546788</code></pre>
<p>If we have a single <span class="math inline">\(I(X)=OC(X)\)</span>,
the OPTICS cordillera (Rusch, Hornik &amp; Mair 2019), and the
transformations applied are power transformations and the weights for
the <span class="math inline">\(I(X)\)</span> is negative we essentially
have P-COPS (see below).</p>
<!--
[!!]: c-evenness: How even and/or spread out are observations ($I_k$ is a function of the Ripley's K and L functions; not yet implemented) * c-randomness: How close to a random pattern (under some model) is the configuration ($I_k$ is not clear yet; not yet implemented) * c-separability: How well are classes (linear and nonlinear) separable. Perhaps only useful if there are labels. ($I_k$ is a separation index; not yet implemented) * c-sparsity: How sparse is the representation (percentage of vectors with 0 or percentage of weights that are zero; not yet implemented) * c-optimality: Finding the global minimum of stress by adding a penalty when the optimum is local ($I_k$ is Jan's idea; not yet implemented)* **c-randomness**: How close to a random pattern (under some model) is the configuration ($I_k$ is not clear yet; not yet implemented)
-->
</div>
<div id="mds-models-for-stops" class="section level4">
<h4>MDS models for STOPS</h4>
<p>For the MDS loss (argument <code>loss</code> in functions
<code>stops</code>), the functions currently support all losses derived
from <em>powerstress</em>, <em>powerstrain</em>, <em>lmds</em> and
<em>bcStress</em>. We offer dedicated functions that either use
workhorses that are more optimized for the problem at hand and/or
restrict the parameter space for the distance/proximity transformations
and thus can be faster. They are:</p>
<ul>
<li><code>stress</code>, <code>smacofSym</code>: Kruskal’s stress;
Workhorse: <code>smacofSym</code>, Optimization over <span class="math inline">\(\theta=\lambda\)</span></li>
<li><code>smacofSphere</code>: Kruskal’s stress for projection onto a
sphere; Workhorse <code>smacofSphere</code>, Optimization over <span class="math inline">\(\theta=\lambda\)</span></li>
<li><code>strain</code>, <code>powerstrain</code>: Classical scaling;
Workhorse: <code>cmdscale</code>, Optimization over <span class="math inline">\(\theta=\lambda\)</span></li>
<li><code>sammon</code>, <code>sammon2</code>: Sammon scaling;
Workhorse: <code>sammon</code> or <code>smacofSym</code>, Optimization
over <span class="math inline">\(\theta=\lambda\)</span></li>
<li><code>elastic</code>: Elastic scaling; Workhorse:
<code>smacofSym</code>, Optimization over <span class="math inline">\(\theta=\lambda\)</span></li>
<li><code>sstress</code>: S-stress; Workhorse:
<code>powerStressMin</code>, Optimization over <span class="math inline">\(\theta=\lambda\)</span></li>
<li><code>rstress</code>: S-stress; Workhorse:
<code>powerStressMin</code>, Optimization over <span class="math inline">\(\theta=\kappa\)</span></li>
<li><code>powermds</code>: MDS with powers; Workhorse:
<code>powerStressMin</code>, Optimization over <span class="math inline">\(\theta=(\kappa,\lambda)\)</span></li>
<li><code>powersammon</code>: Sammon scaling with powers; Workhorse:
<code>powerStressMin</code>, Optimization over <span class="math inline">\(\theta=(\kappa,\lambda)\)</span></li>
<li><code>powerelastic</code>: Elastic scaling with powers; Workhorse:
<code>powerStressMin</code>, Optimization over <span class="math inline">\(\theta=(\kappa,\lambda)\)</span></li>
<li><code>powerstress</code>: Power stress model; Workhorse:
<code>powerStressMin</code>, Optimization over <span class="math inline">\(\theta=(\kappa,\lambda,\nu)\)</span></li>
<li><code>rpowerstress</code>: restricted power stress model; Workhorse:
<code>powerStressMin</code>, Optimization over <span class="math inline">\(\theta=(\kappa,\lambda,\nu)\)</span></li>
<li><code>apstress</code>: Approximate power stress model; Workhorse:
<code>powerStressMin</code>, Optimization over <span class="math inline">\(\theta=(\tau,\upsilon)\)</span></li>
<li><code>lmds</code>: LMDS; Workhorse: <code>lmds</code>, Optimization
over <span class="math inline">\(\theta=(\tau, k)\)</span>.</li>
<li><code>bcstress</code>: Box-Cox MDS; Workhorse:
<code>bcStressMin</code>, Optimization over <span class="math inline">\(\theta=(\mu,\lambda,\rho)\)</span>.</li>
</ul>
</div>
<div id="usage" class="section level4">
<h4>Usage</h4>
<p>The syntax for fitting a <code>stops</code> model is rather
straightforward. One has to supply the arguments <code>dis</code> which
is a dissimilarity matrix and <code>structures</code> a character vector
listing the c-structuredness type that should be used to augment the PS
loss (see above for the types of structures and losses). The
metaparameters for the structuredness indices should be given via the
<code>strucpars</code> argument; it should be a list whose elements are
again lists corresponding to each structuredness index and listing the
parameters (if the default should be used the list element should be set
to <code>NULL</code>). See the example below. The PS loss can be chosen
with the argument <code>loss</code>. The type of aggregation for the
multi-objective optimization is specified in <code>type</code> and can
be one of <code>additive</code> or <code>multiplicative</code>. As
starting value for the <span class="math inline">\(\theta\)</span> one
can supply (<code>theta</code>). If not this will be a scalar <span class="math inline">\(1\)</span>.</p>
<p>For the outer optimization loop the solver can be specified with
<code>optimmethod</code>; per default we use <code>&quot;ALJ&quot;</code>. The
<code>upper</code> and <code>lower</code> box constraints for the outer
loop have to be supplied as well (these need to be of the same dimension
as <code>theta</code>). If <code>theta</code> was not supplied,
<code>upper</code> and <code>lower</code> need to be scalar (so one
value each) and will be recycled to match the length of the
hyperparamater vector. If the maximum number of iterations of the outer
loop needs to be changed, one can use <code>itmax</code> and if the
inner loop maximum number of iterations (for finding the PS
configuration) needs to be changed, one can use the <code>itmaxps</code>
argument. There are additional arguments for the function and one can
pass additional parameters to the fitting workhorses with
<code>...</code> (see <code>?stops</code> for details).</p>
<p>A typical call looks like</p>
<p><code>stops(dis, structures = c(&quot;cclusteredness&quot;,&quot;clinearity&quot;), loss=&quot;stress&quot;, upper=0, lower=1)</code></p>
<p>The returned object contains the MDS object which is usually a
<code>smacof</code> or <code>smacofP</code> class and all S3 methods are
at one’s disposal.</p>
<p>Let us fit an mSTOPS model that looks for a transformation of the
<span class="math inline">\(\delta_{ij}\)</span> so that a) the result
has maximal <em>c-clusteredness</em> (which is 1 in the best case, so we
set a negative weight for this structure) b) the projection onto the
principal axes are nearly orthogonal (<em>c-linearity</em> close to 0,
so we set a positive weight for this structure) c) but the projections
onto the principal axes should be stochastically dependent (negative
weight on <em>c-dependence</em>) and d) the fit of the MDS is also
factored in (so we set positive weight on the MDS loss).</p>
<p>We first setup the structures:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>structures<span class="ot">&lt;-</span><span class="fu">c</span>(<span class="st">&quot;cclusteredness&quot;</span>,<span class="st">&quot;clinearity&quot;</span>,<span class="st">&quot;cdependence&quot;</span>)</span></code></pre></div>
<p>featuring the structures we mentioned.</p>
<p>Next we set up the metaparameters for the c-structuredness indices
(the <span class="math inline">\(gamma\)</span>). This must be a list of
lists. Each list element corresponds to a structure in the same ordering
as in the <code>structures</code> argument (so first c-clusterednes,
then c-linearity, then c-dependence). Each of the list elements is again
a list with the named arguments that should be supplied to the
structure. If there are no metaparameters for a structure, the list
should be <code>NULL</code>. Let’s illustrate with an example. For the
OPTICS cordillera (c-lcusteredness) we may want metaparameters
<code>dmax=1</code>, <code>epsilon=10</code> and <code>minpts=2</code>,
so we need to put them in a list with named elements as
<code>list(epsilon=10,minpts=2,dmax=1.3)</code>. For c-linearity we have
no parameters, so we use <code>NULL</code> (or <code>list(NULL)</code>).
For the c-dependence we have a single parameter, <code>index</code>
which we set to 1.2 in another named list as
<code>list(index=1.2)</code>. We then create a list with these list as
elements:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>strucpars<span class="ot">&lt;-</span><span class="fu">list</span>(</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>                <span class="fu">list</span>(<span class="at">epsilon=</span><span class="dv">10</span>,<span class="at">minpts=</span><span class="dv">2</span>,<span class="at">dmax=</span><span class="fl">1.3</span>),  <span class="co"># element 1: list of arguments for c-clusteredness </span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>                <span class="cn">NULL</span>,                                <span class="co"># element 2: argument for c-linearity (empty as it has no parameters)</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>                <span class="fu">list</span>(<span class="at">index=</span><span class="fl">1.2</span>)                      <span class="co"># element 3: list of arguments for c-dependence</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>                ) </span></code></pre></div>
<p>If some arguments are not listed, the default values are taken. If
there’s only one structre, we don’t need a list of list but the list of
metaparameters suffices.</p>
<p>Since we use mSTOPS and a negative weight for c-linearity and
c-dependence, a c-linearity/c-dependence close to 0 will overall
dominate the stoploss function with the other two criteria being more of
an afterthought - in aSTOPS that would be different. We weight all of
them equally (<span class="math inline">\(0.33\)</span>).</p>
<p><a href="The%20implementation%20in%20%60powerStressMin%60%20is%20more%20a%20proof-of-concept%20than%20optimal.%20Majorizing%20this%20type%20of%20stress%20is%20a%20pretty%20hard%20problem%20and%20the%20code%20we%20use%20relies%20on%20a%20while%20loop%20in%20pure%20R.%20We%20plan%20to%20speed%20the%20loop%20up%20with%20a%20re-implementation%20in%20C%20in%20the%20future.">!!</a>:
This is generally the approach to be chosen: We <em>minimize</em> the
stoploss, so a c-structuredness index that should be (numerically) large
needs a <em>negative weight</em> and a c-structuredness index that
should be (numerically) small needs a <em>positive weight</em>.</p>
<p>We now run <code>stops</code>.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">666</span>)</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>ressm<span class="ot">&lt;-</span><span class="fu">stops</span>(kinshipdelta,<span class="at">loss=</span><span class="st">&quot;stress&quot;</span>,<span class="at">stressweight=</span><span class="dv">1</span>,<span class="at">structures=</span><span class="fu">c</span>(<span class="st">&quot;cclusteredness&quot;</span>,<span class="st">&quot;clinearity&quot;</span>,<span class="st">&quot;cdependence&quot;</span>),<span class="at">strucweight=</span><span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.33</span>,<span class="fl">0.33</span>,<span class="sc">-</span><span class="fl">0.33</span>),<span class="at">verbose=</span><span class="dv">0</span>,<span class="at">strucpars=</span>strucpars,<span class="at">type=</span><span class="st">&quot;multiplicative&quot;</span>,<span class="at">lower=</span><span class="dv">0</span>,<span class="at">upper=</span><span class="dv">8</span>)</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>ressm</span></code></pre></div>
<pre><code>## 
## Call: stops(dis = kinshipdelta, loss = &quot;stress&quot;, structures = c(&quot;cclusteredness&quot;, 
##     &quot;clinearity&quot;, &quot;cdependence&quot;), stressweight = 1, strucweight = c(-0.33, 
##     0.33, -0.33), strucpars = strucpars, lower = 0, upper = 8, 
##     verbose = 0, type = &quot;multiplicative&quot;)
## 
## Model: multiplicative STOPS with stress loss function and theta parameter vector (kappa lambda rho)  =  1 1.432493 1 
## 
## Number of objects: 15 
## MDS loss value: 0.06970603 
## C-Structuredness Indices: cclusteredness 0.24108469 clinearity 0.02696876 cdependence 0.20524114 
## Structure optimized loss (stoploss): 0.05705468 
## MDS loss weight: 1 c-structuredness weights: -0.33 0.33 -0.33 
## Number of iterations of ALJ optimization: 28</code></pre>
<p>The print function gives us information about the model. The selected
hyperparameter was <span class="math inline">\(\lambda=\)</span>
1.4324926. With that and the given metaparameters of the indices we have
values of 0.24 for c-clusteredness, 0.03 for c-linearity and 0.20 for
c-dependence. Stress was 0.0571, and stress-1 (the square root of raw
stress) is sqrt(0.0571)=0.26.</p>
<p>We plot the obtained configuration (the one for <span class="math inline">\(\lambda=1.4\)</span>).</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(ressm)</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>We can see that the configuration mimics the structuredness we wanted
(there is clusteredness, i.e., the terms are arranged in clusters, the
projection is near orthogonal but there is a stochastic dependence that
is nonlinear. This is a star-shaped arrangement. (No, this is
Patrick).</p>
<p>Let us compare this with the corresponding aSTOPS</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>ressa<span class="ot">&lt;-</span><span class="fu">stops</span>(kinshipdelta,<span class="at">loss=</span><span class="st">&quot;stress&quot;</span>,<span class="at">stressweight=</span><span class="dv">1</span>,<span class="at">structures=</span><span class="fu">c</span>(<span class="st">&quot;cclusteredness&quot;</span>,<span class="st">&quot;clinearity&quot;</span>,<span class="st">&quot;cdependence&quot;</span>),<span class="at">strucweight=</span><span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.33</span>,<span class="fl">0.33</span>,<span class="sc">-</span><span class="fl">0.33</span>),<span class="at">verbose=</span><span class="dv">0</span>,<span class="at">strucpars=</span>strucpars,<span class="at">type=</span><span class="st">&quot;additive&quot;</span>,<span class="at">lower=</span><span class="dv">0</span>,<span class="at">upper=</span><span class="dv">8</span>)</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>ressa</span></code></pre></div>
<pre><code>## 
## Call: stops(dis = kinshipdelta, loss = &quot;stress&quot;, structures = c(&quot;cclusteredness&quot;, 
##     &quot;clinearity&quot;, &quot;cdependence&quot;), stressweight = 1, strucweight = c(-0.33, 
##     0.33, -0.33), strucpars = strucpars, lower = 0, upper = 8, 
##     verbose = 0, type = &quot;additive&quot;)
## 
## Model: additive STOPS with stress loss function and theta parameter vector (kappa lambda rho)  =  1 1.483125 1 
## 
## Number of objects: 15 
## MDS loss value: 0.07037108 
## C-Structuredness Indices: cclusteredness 0.24482385 clinearity 0.02667558 cdependence 0.20393552 
## Structure optimized loss (stoploss): -0.06891657 
## MDS loss weight: 1 c-structuredness weights: -0.33 0.33 -0.33 
## Number of iterations of ALJ optimization: 25</code></pre>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(ressa)</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>We see that the c-clusteredness is a bit higher as compared to the
mSTOPS result - we have a number of distinct object clusters (with at
least minpts=2) and they are more spread out and distributed more
evenly.</p>
<p>When choosing a c-structuredness index, one needs to be clear what
structure one might be interested in and how it interacts with the PS
loss chosen. Consider the following example: We fit a
<code>powermds</code> model to the kinship data and want to maximize
c-association (i.e., any non-linear relationship) and c-manifoldness but
minimize the c-linearity. In other words we try to find a power
transformation of <span class="math inline">\(\Delta\)</span> and <span class="math inline">\(D\)</span> so that the objects are positioned in
the configuration in such a way that the projection onto the principal
axes are as close as possible to being related by a smooth but
non-linear function.</p>
<p>We use <code>tgp</code> as optimization method and restrict the
search space to be between <span class="math inline">\(0\)</span> and
<span class="math inline">\(5\)</span>.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">666</span>)</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>resa<span class="ot">&lt;-</span><span class="fu">stops</span>(kinshipdelta,<span class="at">structures=</span><span class="fu">c</span>(<span class="st">&quot;cassociation&quot;</span>,<span class="st">&quot;cmanifoldness&quot;</span>,<span class="st">&quot;clinearity&quot;</span>),<span class="at">loss=</span><span class="st">&quot;powermds&quot;</span>,<span class="at">theta=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>),<span class="at">strucpars=</span><span class="fu">list</span>(<span class="cn">NULL</span>,<span class="cn">NULL</span>,<span class="cn">NULL</span>),<span class="at">type=</span><span class="st">&quot;additive&quot;</span>,<span class="at">strucweight=</span><span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.5</span>,<span class="sc">-</span><span class="fl">0.5</span>,<span class="fl">0.5</span>),<span class="at">lower=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>),<span class="at">upper=</span><span class="fu">c</span>(<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>),<span class="at">optimmethod=</span><span class="st">&quot;tgp&quot;</span>,<span class="at">itmaxps=</span><span class="dv">1000</span>,<span class="at">itmax=</span><span class="dv">10</span>)</span></code></pre></div>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>resa</span></code></pre></div>
<pre><code>## 
## Call: stops(dis = kinshipdelta, loss = &quot;powermds&quot;, theta = c(1, 1, 
##     1), structures = c(&quot;cassociation&quot;, &quot;cmanifoldness&quot;, &quot;clinearity&quot;), 
##     strucweight = c(-0.5, -0.5, 0.5), strucpars = list(NULL, 
##         NULL, NULL), optimmethod = &quot;tgp&quot;, lower = c(0, 0, 0), 
##     upper = c(5, 5, 5), type = &quot;additive&quot;, itmax = 10, itmaxps = 1000)
## 
## Model: additive STOPS with powermds loss function and theta parameter vector (kappa lambda rho)  =  0.2812266 1.355201 1 
## 
## Number of objects: 15 
## MDS loss value: 0.05717448 
## C-Structuredness Indices: cassociation 0.21289663 cmanifoldness 0.96451410 clinearity 0.03428154 
## Structure optimized loss (stoploss): -0.5143901 
## MDS loss weight: 1 c-structuredness weights: -0.5 -0.5 0.5 
## Number of iterations of tgp optimization: 10</code></pre>
<p>We see in this model (<code>resa</code>) that indeed the
c-manifoldness is almost 1 and c-association is high, which says we have
a close to perfect non-linear relationship. How does this relationship
look like?</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(resa)</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<!-- It resembles a simplex (the manifold), so the projections are so that the points on D2 are a near parabolic function of the D1 (projecting onto some structure resembling a conic section is often the case for r-stress which is essentially what we got here - setting a negative weight on c-assocation can combat that if that is an artefact). What we can also see is that there are three clear clusters, so c-clusteredness should be high. But when looking at the OPTICS cordillera here, we find that the OPTICS cordillera is lower than for the result from above with using `stress` and lambda=2.66 (the `ressa` model).
-->
<p>It resembles a simplex (the manifold) and since the objects are
arranged at the vertices, this is also associated (non-linearly).</p>
<p>What we can also see is that there are three clear clusters of 4 or
more objects, so c-clusteredness should be high (but we didn’t select
for that). When looking at the OPTICS cordillera here, we find that the
OPTICS cordillera with minpts=4 is indeed higher than for the result
from above with using <code>stress</code> (the <code>ressa</code>
model).</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(cordillera)</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>c1<span class="ot">&lt;-</span><span class="fu">cordillera</span>(resa<span class="sc">$</span>fit<span class="sc">$</span>conf,<span class="at">minpts=</span><span class="dv">4</span>,<span class="at">epsilon=</span><span class="dv">10</span>,<span class="at">dmax=</span><span class="fl">1.3</span>)</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>c2<span class="ot">&lt;-</span><span class="fu">cordillera</span>(ressa<span class="sc">$</span>fit<span class="sc">$</span>conf,<span class="at">minpts=</span><span class="dv">4</span>,<span class="at">epsilon=</span><span class="dv">10</span>,<span class="at">dmax=</span><span class="fl">1.3</span>)</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>c1</span></code></pre></div>
<pre><code>##       raw    normed 
## 0.2175737 0.0632578</code></pre>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>c2</span></code></pre></div>
<pre><code>##        raw     normed 
## 0.19053493 0.05539649</code></pre>
<p>This comes from the definition of c-clusteredness (Rusch, Hoornik
&amp; Mair, 2019) where more clusters, more spread-out clusters, more
evenly distributed clusters and denser clusters all increase
c-clusteredness.</p>
<!---
In the example with maximizing c-association we have two very dense clusters of 5 points and 1 relatively non-dense cluster of five other points. In the model maximizing c-clusteredness (and others) we get 6 relatively moderate dense clusters with 2 or 3 points each, which is also the minimum number of points we wanted to be grouped together. Most importantly, they are projected onto a much larger range of the target space as the $X$ obtained from the `stress` loss is different than the one obtained from the `powermds` loss, so the $d_{max}$ is very different. Since we use the normed OPTICS cordillera there, we look at c-clusteredness relative to the most clustered appearance with two points per cluster. Thus, the second result has more c-clusteredness. If we would define a cluster as having at most 5 points then c-clusteredness of the result with high c-association also has a large c-clusteredness because then the clusters found match the definition of high c-clusteredness. 
--->
<p>Note that it may just as well be possible to have a high
c-association and no c-clusteredness at all (e.g., points lying
equidistant on a smooth non-linear curve), as we did not optimize for
the latter. Note also that the models are not necessarily comparable due
to different stress functions - the transformation in
<code>powermds</code> that is optimal with respect to c-clusteredness
would be different.</p>
<p>Indeed one can even optimize for c-clusteredness alone (setting
<code>stressweight=0</code>) and using it as a
“goodness-of-clusteredness” index (i.e., we let the <span class="math inline">\(d_{max}\)</span> vary between the configurations
and take the highest attainable nomred cordillera) then we get a
projection with c-clusteredness of 0.71.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>resa2<span class="ot">&lt;-</span><span class="fu">stops</span>(kinshipdelta,<span class="at">structures=</span><span class="fu">c</span>(<span class="st">&quot;cclusteredness&quot;</span>),<span class="at">loss=</span><span class="st">&quot;powermds&quot;</span>,<span class="at">strucpars=</span><span class="fu">list</span>(<span class="fu">list</span>(<span class="at">epsilon=</span><span class="dv">10</span>,<span class="at">dmax=</span><span class="cn">NULL</span>,<span class="at">minpts=</span><span class="dv">2</span>)),<span class="at">type=</span><span class="st">&quot;additive&quot;</span>,<span class="at">strucweight=</span><span class="sc">-</span><span class="dv">1</span>,<span class="at">stressweight=</span><span class="dv">0</span>,<span class="at">lower=</span><span class="fl">0.1</span>,<span class="at">upper=</span><span class="dv">10</span>)</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>resa2</span></code></pre></div>
<pre><code>## 
## Call: stops(dis = kinshipdelta, loss = &quot;powermds&quot;, structures = c(&quot;cclusteredness&quot;), 
##     stressweight = 0, strucweight = -1, strucpars = list(list(epsilon = 10, 
##         dmax = NULL, minpts = 2)), lower = 0.1, upper = 10, type = &quot;additive&quot;)
## 
## Model: additive STOPS with powermds loss function and theta parameter vector (kappa lambda rho)  =  1.61284 1.61284 1 
## 
## Number of objects: 15 
## MDS loss value: 0.1090212 
## C-Structuredness Indices: cclusteredness 0.7189709 
## Structure optimized loss (stoploss): -0.7189709 
## MDS loss weight: 0 c-structuredness weights: -1 
## Number of iterations of ALJ optimization: 35</code></pre>
<p>This can of course be done for an c-structuredness.</p>
<p>It is also possible to use the <code>stops</code> function for
finding the hyperparameters that are optimal for minimizing the
badness-of-fit for a given transformation class in the the non-augmented
models specified in <code>loss</code>, by setting the
<code>strucweight</code> (the weight of any c-structuredness) to 0. Then
the function optimizes the MDS loss function only.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>ressa<span class="ot">&lt;-</span><span class="fu">stops</span>(kinshipdelta,<span class="at">structure=</span><span class="fu">c</span>(<span class="st">&quot;clinearity&quot;</span>),<span class="at">strucweight=</span><span class="dv">0</span>,<span class="at">loss=</span><span class="st">&quot;stress&quot;</span>,<span class="at">verbose=</span><span class="dv">0</span>,<span class="at">upper=</span><span class="dv">8</span>,<span class="at">lower=</span><span class="dv">0</span>)</span></code></pre></div>
<p>Here the minimum badness-of-fit by subjecting the <span class="math inline">\(\delta\)</span> to a power transformation <span class="math inline">\(\delta^*=\delta^\lambda\)</span> is obtained with
<span class="math inline">\(\lambda=1.297\)</span> and a stress-1 of
<span class="math inline">\(0.069\)</span>. This strategy is similar to
how the optimal scaling of dhats works within other MDS methods (e.g.,
in nonmetric and spline MDS).</p>
</div>
</div>
<div id="cops" class="section level3">
<h3>COPS</h3>
<p>A special STOPS model is P-COPS (Rusch, Mair &amp; Hornik 2021).
Along the lines of STOPS the overall objective function, which we call ,
is a weighted combination of the <span class="math inline">\(\theta-\)</span>parametrized loss function, <span class="math inline">\(\sigma_{MDS}\left(X(\theta),\theta\right)\)</span>,
and a c-clusteredness measure, the OPTICS cordillera or <span class="math inline">\(OC(X(\theta);\epsilon,k,q)\)</span> to be
optimized as a function of <span class="math inline">\(\theta\)</span>
or <span class="math display">\[\begin{equation}
\label{eq:spstress}
\text{coploss}(\theta) = v_1 \cdot \sigma_{MDS}\left(X(\theta),\theta
\right) - v_2 \cdot \text{OC}\left(X(\theta);\epsilon,k,q\right)
\end{equation}\]</span> with <span class="math inline">\(v_1,v_2 \in
\mathbb{R}\)</span> controlling how much weight should be given to the
scaling fit measure and the c-clusteredness. The c-clusteredness index
we use is the OPTICS cordillera which measures how clustered a
configuration appears. It is based on the OPTICS algorithm that outputs
an ordering together with a distance. The OPTICS cordillera is now
simply an agregation of that information. Since we know what constitutes
a maximally clustered result, we can derive an upper bound and normalize
the index to lie between 0 and 1. If it is maximally clustered, the
index gets a value of 1,and it gets 0 if all points are equidistant to
their nearest neighbours (a matchstick embedding). See the vignette in
the COPS package for more.</p>
</div>
<div id="optimization-1" class="section level3">
<h3>Optimization</h3>
<p>Since the inner optimization problem in STOPS models is hard and
takes long, Rusch, Mair and Hornik (2021) developed a metaheuristic for
the outer optimization problem that typically needs less calls to the
inner minimization than <code>pso</code> or <code>SANN</code>, albeit
without the guarantees of convergence to a global minimum for non-smooth
functions. It is an adaptation of the Luus-Jaakola random search (Luus
&amp; Jaakola 1973). It can used with the function <code>ljoptim</code>
which modeled its output after <code>optim</code>. It needs as arguments
<code>x</code> a starting value, <code>fun</code> a function to
optimize, a <code>lower</code> and <code>upper</code> box constraint for
the search region. By using the argument <code>adaptive=TRUE</code> or
<code>FALSE</code> one can switch between our adaptive version and the
original LJ algorithm. Accuracy of the optimization can be controlled
with the <code>maxit</code> (maximum number of iterations),
<code>accd</code> (terminates after the length of the search space is
below this number ) and <code>acc</code> arguments (terminates if
difference of two subsequent function values are below this value).</p>
<p>We optimize a “Wild Function” with the non-adaptive LJ version (and
numerical accuracies of at least <code>1e-16</code> for
<code>accd</code> and <code>acc</code>).</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">210485</span>)</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>fwild <span class="ot">&lt;-</span> <span class="cf">function</span> (x) <span class="dv">10</span><span class="sc">*</span><span class="fu">sin</span>(<span class="fl">0.3</span><span class="sc">*</span>x)<span class="sc">*</span><span class="fu">sin</span>(<span class="fl">1.3</span><span class="sc">*</span>x<span class="sc">^</span><span class="dv">2</span>) <span class="sc">+</span> <span class="fl">0.00001</span><span class="sc">*</span>x<span class="sc">^</span><span class="dv">4</span> <span class="sc">+</span> <span class="fl">0.2</span><span class="sc">*</span>x<span class="sc">+</span><span class="dv">80</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>res2<span class="ot">&lt;-</span><span class="fu">ljoptim</span>(<span class="dv">50</span>, fwild,<span class="at">lower=</span><span class="sc">-</span><span class="dv">50</span>,<span class="at">upper=</span><span class="dv">50</span>,<span class="at">adaptive=</span><span class="cn">FALSE</span>,<span class="at">accd=</span><span class="fl">1e-16</span>,<span class="at">acc=</span><span class="fl">1e-16</span>)</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>res2</span></code></pre></div>
<pre><code>## $par
## [1] -15.81515
## 
## $value
## [1] 67.46773
## 
## $counts
## function gradient 
##      463       NA 
## 
## $convergence
## [1] 0
## 
## $message
## NULL</code></pre>
<div class="sourceCode" id="cb69"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(fwild, <span class="sc">-</span><span class="dv">50</span>, <span class="dv">50</span>, <span class="at">n =</span> <span class="dv">1000</span>, <span class="at">main =</span> <span class="st">&quot;ljoptim() minimising &#39;wild function&#39;&quot;</span>)</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a><span class="fu">points</span>(res2<span class="sc">$</span>par,res2<span class="sc">$</span>value,<span class="at">col=</span><span class="st">&quot;red&quot;</span>,<span class="at">pch=</span><span class="dv">19</span>)</span></code></pre></div>
<p><img src="data:image/png;base64,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dCO1aaipqUl7fzweb25u1j6gt9u6devNN9986623jhw58vHHH6+rq1u9enX//v2FEJ0+8lE1M15++WV153PPPdehJxk/frws49FHHxVCTJ48WQghR1v+/Oc/CyFOO+20dLpcasPU888/r+7UfsulyWazCSFqamrU/HsnPj9yYEsI8eabb6o758+fP378eO2iWPvPkP5PDZCdCEDId06nU/YYPv300/nz57///vsvvPCCHM4wGo0///nPEx5//vnn/+Uvf3nuuedmz54txyCuvPJK+So1DNH+qk36BgwY4HQ6hRBfffWV9v59+/bJd6375RG6SyQSufPOO++8884rr7zynXfe2bNnj8FgkHNOnf4YBw0adNpppwkhNmzYcPnll69du/a666575JFHOvQkBoNBZgK50CkD0IknniiEkLuo0ln/EkKMHTtWHnjz97///corr1y7du2VV16Z8iyi9snscvDgwcsuu+yll176zW9+c//993f0SQYMGCAnml955ZWbb755y5Ytv/71r1euXPmvf/1Lzei0/83c0Z8aIAsRgABx9913y/3GK1eunD59+rnnniv/kF2yZEnC3uN+/fo1NjYuXLjw/PPPl5Oe55xzjjpaRm7xFUJcfvnls2bN6nphFotl+vTpIumvfHkGdHFx8be//e2uv5dsMHny5HPOOUcc2TY/evToH/zgBzJhXHvttZ1+2qVLl8ptXI899tjs2bPvv/9+tS6WPm3EkScQar8rZsyYkebz3HfffXJy609/+tPs2bP/9Kc/lZWVdbSYK664Qt544okn5s6de/fdd6t2Tofcd999cp3xzjvvPOmkk+TFyCorK3/3u9/JBxz1mzn9nxogOxGAANGvX7/t27f/5je/mTx5ssvlqqiomDVr1ptvvnnnnXcmPLKysnLVqlXTp08vKio64YQT7rzzzhdeeEG9dsaMGb/4xS/69u1rNBq7a5OLTFerV6+WLR9JTp98//vflz2SHGA0Gv/6178+/PDD06ZNKy8vt1qtgwcPPvPMM1999dWLLrqo0087efLkDz74YPbs2f369RsyZMgVV1whP3UdogJQRUWFnPlVv+AHDhx47LHHpvk8kyZN2rJly9y5cwcMGDBkyJBFixatWrVq3Lhx48aNSz+WzZkz56mnnho3blxBQcG3v/3tpUuXPvTQQ/JJEibl23fcccd9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PWfPnq2urnZ7ICUumUx+9tlniUTC7YGUvuPHj69YscLtUbjj1KlTbn1pDwWgtWvX/vOf/2xvb3d7IC545ZVX/H5/LBZzeyAl7tSpU319fbww59q5c+dOnz49YcIEtwdS4i5evHjkyJHGxka3B1L6Dh48WFdXFwqF3B6IC+64446GhgZXvrQvmUy68oWRT3fdddfSpUtXrVrl9kBK3NatW8+fP79lyxa3B1LiXn755e3bt//hD39weyAl7siRI/Pnzz98+LDbAyl98Xj86NGj/B81z+gBAgAAnkMAAgAAnkMAAgAAnkMAAgAAnkMAAgAAnkMAAgAAnkMAAgAAnkMA8oRAIBAMBt0eRekLBoOBgIc2F3UL1zk/AoEA1zk/gsGg3+93exSew0aInnD27NloNMrfslzr6upKJpORSMTtgZS43t7ezs7OiooKtwdS+k6dOjV27Fi3R1H6uM6uIAABAADPYQoMAAB4DgEIAAB4DgEIAAB4DgEIAAB4DgEIAAB4DgEIAAB4DgEIAAB4DgEIAAB4DgEIAAB4DgEIAAB4DgEIAAB4DgEIAAB4DgGoxF26dGnu3Llf+9rXzDt37tx5ww03VFRULFiw4O9//7tbYysNPT09W7dubWlpiUajra2tjz/++MWLF/V7udQjjkuaC/wY5x9/nF1HACpx69evt/0WPffcc6tXr54/f/6OHTsqKysXLlz4/vvvuzW8ErBx48bNmzffc889u3fvXrly5YYNG77zne/Iu7jUI45LmiP8GOcff5zdl0Tpeumll8aMGTNx4sS7775b3zlt2rS77rpLbl+6dGny5Mn333+/SwMser29veFw+JFHHtH3PProo8FgsKurK8mlzgEuaS7wY5x//HEuBFSAStbhw4fvu+++p59+uqamRt959OjR/fv3L1++XN70+/3Lli3bs2ePS2MseseOHZs4ceLixYv1PVdeeeXFixdPnjzJpR5xXNIc4cc4z/jjXCAIQKWpp6dnxYoV991337Jly8z7jx07ppSaOHGivqehoeHEiRO9vb35HmJJqKur++ijj+bMmSNvdnV1bd++vbGxsa6ujks94rikOcKPcT7xx7lwEIBK00MPPeT3+3/4wx/a7m9vb1dKxeNxfU88Hu/r65P7MRz79u2bN2/evn37nnnmGcuyuNQjjkuaB/wY5xp/nAsHAagU/OUvf/GlrF+/fvfu3bt27frtb38bDAZtj6ysrFRKdXZ26ns6Ojosy6qoqMjriIuW7VLLne3t7WvWrLnhhhsmTJjwwQcfzJ49W3Gpc4BLmlP8GOcBf5wLSsDtAWAEzJ49+8CBA3K7srJy69at7e3tZin1rbfeevbZZ3//+99fd911SqmjR4/OmDFD3nX06NFx48Y5fxuRlu1SK6U+/vjjBQsWVFZWvvXWWzNnztSPTCQSiks9orikucOPcX688cYb/HEuHL5kMun2GDDCDh06dPToUf3munXrEonE+vXrp02bVl1dPXXq1BtvvHH79u1KqWQyOWPGjOuvv/5Xv/qVe+MtYslkcurUqRMmTPjd735XXl5uey+XesRxSXOBH+O84Y9zQaECVIKampqampr0m/F4vKam5otf/KK8+d3vfvfee+9taWmZPXv2zp07Dx069Mwzz7g00qK3d+/eDz/88JZbbnnuuefM+7/61a+Gw2Eu9YjjkuYCP8Z5wx/nwuLeCnzkyY033mhuNZFMJnfu3DljxoxYLDZv3ry9e/e6NbAS8Itf/CLtr9Xx48flAVzqEcclHXH8GLuFP87uYgoMAAB4DqvAAACA5xCAAACA5xCAAACA5xCAAACA5xCAAACA5xCAAACA5xCAAACA5xCAAACA5xCAAACA5xCAAACA5xCAAACA5xCAAACA5xCAAACA5xCAAACA5xCAAACA5xCAAACA5xCAAACA5xCAAACA5xCAAACA5xCAAACA5xCAAACA5xCAAACA5xCAAACA5xCAAACA5xCAAACA5xCAAACA5xCAAACA5xCAAACA5xCAABSHP//5z5Zlvf766/Lmiy++GAqF9u/f7+qgABQrXzKZdHsMADAo995779tvv/3+++9fuHChpaVl9erVmzdvdntQAIoSAQhA0fjvf//b0tLywAMPtLe3v/LKK++9915ZWZnbgwJQlAJuDwAABquqqurHP/7x/fff39fX99prr5F+AFw2KkAAisnFixdramrGjRv34Ycf+nw+t4cDoFjRBA2gmDz++OOhUOiTTz7ZuXOn22MBUMSoAAEoGgcPHrz22mt37dr17rvv/vznPz9w4EBVVZXbgwJQlAhAAIpDMpmcP39+LBbbs2dPV1dXa2vrvHnzqAMBuDxMgQEoDk899dQ777zzxBNPKKXC4fATTzzx61//Wm8LBABDQgUIAAB4DhUgAADgOQQgAADgOQQgAADgOQQgAADgOQQgAADgOQQgAADgOQQgAADgOQQgAADgOQQgAADgOQQgAADgOQQgAADgOQQgAADgOQQgAADgOQQgAADgOQQgAADgOQQgAADgOQQgAADgOQQgAADgOQQgAADgOQQgAADgOQQgAADgOQQgAADgOQQgAADgOQQgAADgOf8PIijH+r7rCx8AAAAASUVORK5CYII=" /><!-- --></p>
</div>
<div id="procrustes-adjustment" class="section level3">
<h3>Procrustes Adjustment</h3>
<p>We also provide a procrustes adjustment to make two configurations
visually comparable. The function is <code>conf_adjust</code> and takes
two configurations <code>conf1</code> the reference configuration and
<code>conf2</code> another configuration. It returns the adjusted
versions</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="fu">conf_adjust</span>(conf1,conf2) </span></code></pre></div>
<p>##References</p>
<ul>
<li><p>Borg I, Groenen PJ (2005). Modern multidimensional scaling:
Theory and applications. 2nd edition. Springer, New York</p></li>
<li><p>Buja A, Swayne DF, Littman ML, Dean N, Hofmann H, Chen L (2008).
Data visualization with multidimensional scaling. Journal of
Computational and Graphical Statistics, 17 (2), 444-472.</p></li>
<li><p>Chen L, Buja A (2013). Stress functions for nonlinear dimension
reduction, proximity analysis, and graph drawing. Journal of Machine
Learning Research, 14, 1145-1173.</p></li>
<li><p>Chen L, Buja A (2009). “Local multidimensional scaling for
nonlinear dimension reduction, graph drawing, and proximity analysis.”
Journal of the American Statistical Association, 104(485),
209–219.</p></li>
<li><p>de Leeuw J (2014). Minimizing r-stress using nested majorization.
Technical Report, UCLA, Statistics Preprint Series.</p></li>
<li><p>de Leeuw J, Mair P (2009). Multidimensional Scaling Using
Majorization: SMACOF in R. Journal of Statistical Software, 31 (3),
1-30.</p></li>
<li><p>Kruskal JB (1964). Multidimensional scaling by optimizing
goodness of fit to a nonmetric hypothesis. Psychometrika, 29 (1),
1-27.</p></li>
<li><p>Luus R, Jaakola T (1973). Optimization by direct search and
systematic reduction of the size of search region. American Institute of
Chemical Engineers Journal (AIChE), 19 (4), 760-766.</p></li>
<li><p>McGee VE (1966). The multidimensional analysis of ‘elastic’
distances. British Journal of Mathematical and Statistical Psychology,
19 (2), 181-196.</p></li>
<li><p>Reshef D, Reshef Y, Finucane H, Grossman S, McVean G, Turnbaugh
P, Lander E, Mitzenmacher M, Sabeti P (2011). Detecting novel
associations in large datasets. Science, 334, 6062.</p></li>
<li><p>Rosenberg S, Kim MP (1975). The method of sorting as a data
gathering procedure in multivariate research. Multivariate Behavioral
Research, 10, 489-502.</p></li>
<li><p>Rusch T, Mair P, Hornik K (2020). STOPS: Structure Optimized
Proximity Scaling. Discussion Paper Series / Competence Center for
Empirical Research Methods, No 2020/1, WU Vienna, Austria.</p></li>
<li><p>Rusch T, Mair P, Hornik K (2021) Cluster Optimized Proximity
Scaling. Journal of Computational and Graphical Statistics, 30:4,
1156-1167.</p></li>
<li><p>Rusch T, Mair P, Hornik K (2023a). Structure-based hyperparameter
selection with Bayesian optimization in multidimensional scaling.
Statistics &amp; Computing, 33:28.</p></li>
<li><p>Rusch T, Mair P, Hornik K (2023b). Supplement to “Structure-based
hyperparameter selection with Bayesian optimization in multidimensional
scaling”. Statistics &amp; Computing, 33:28.</p></li>
<li><p>Sammon JW (1969). A nonlinear mapping for data structure
analysis. IEEE Transactions on Computers, 18 (5), 401-409</p></li>
<li><p>Sarmanov OV (1958) The maximum correlation coefficient (symmetric
case). Dokl. Akad. Nauk SSSR, 120 : 4 (1958), 715 - 718.</p></li>
<li><p>Székely GJ, Rizzo ML, Bakirov NK (2007). Measuring and testing
independence by correlation of distances, The Annals of Statistics,
35:6, 2769–2794.</p></li>
<li><p>Takane Y, Young F, de Leeuw J (1977). Nonmetric individual
differences multidimensional scaling: an alternating least squares
method with optimal scaling features. Psychometrika, 42 (1),
7-67.</p></li>
<li><p>Torgerson WS (1958). Theory and methods of scaling.
Wiley.</p></li>
<li><p>Venables WN, Ripley BD (2002). Modern Applied Statistics with S.
Fourth edition. Springer, New York.</p></li>
</ul>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
