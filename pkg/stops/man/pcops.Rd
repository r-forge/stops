% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cops.R
\name{pcops}
\alias{pcops}
\title{Profile COPS Function (aka COPS Variant 2)}
\usage{
pcops(dis, loss = c("stress", "smacofSym", "smacofSphere", "strain", "sammon",
  "rstress", "powermds", "sstress", "elastic", "powersammon", "powerelastic",
  "powerstress", "sammon2", "powerstrain"), weightmat = NULL, ndim = 2,
  init = NULL, theta = c(1, 1, 1), stressweight = 1, cordweight, q = 1,
  minpts = ndim + 1, epsilon = 10, rang, optimmethod = c("ALJ", "pso",
  "SANN"), lower = c(1, 1, 0.5), upper = c(5, 5, 2), verbose = 0,
  scale = TRUE, normed = TRUE, s = 4, stresstype = "default", ...)
}
\arguments{
\item{dis}{numeric matrix or dist object of a matrix of proximities}

\item{loss}{which loss function to be used for fitting, defaults to strain. Currently allows for the following models:
\itemize{
\item Power transformations of observed proximities only: Strain loss or classical scaling (\code{strain}, workhorse is cmdscale), Kruskall's stress for symmetric matrices (\code{smacofSym} or \code{stress} and \code{smacofSphere} for scaling onto a sphere; workhorse is smacof), Sammon mapping (\code{sammon} or \code{sammon2}; for the earlier the workhorse is sammon from MASS for the latter it is smacof), elastic scaling (\code{elastic}, the workhorse is smacof), Takane et al's S-Stress \code{sstress} (workhorse is powerStressMin)
\item Power transformations of fitted distances only: De Leeuw's r-stress \code{rstress} (workhorse is powerStressMin)
\item Power transformations of fitted distances and observed proximities: Powermds \code{powermds}, Sammon mapping and elastic scaling with powers (\code{powersammon}, \code{powerelastic}; workhorse is powerStressMin)
}}

\item{weightmat}{(optional) a matrix of nonnegative weights; defaults to 1 for all off diagonals}

\item{ndim}{number of dimensions of the target space}

\item{init}{(optional) initial configuration}

\item{theta}{the theta vector of powers; the first is kappa (for the fitted distances if it exists), the second lambda (for the observed proximities if it exist), the third is nu (for the weights if it exists) . If a scalar is given as argument, it will take the role designated by the loss argument. Defaults to 1 1 1}

\item{stressweight}{weight to be used for the fit measure; defaults to 1}

\item{cordweight}{weight to be used for the cordillera; if missing gets estimated from the initial configuration so that coploss = 0 for theta=c(1,1)}

\item{q}{the norm of the corrdillera; defaults to 1}

\item{minpts}{the minimum points to make up a cluster in OPTICS; defaults to ndim+1}

\item{epsilon}{the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10}

\item{rang}{range of the minimum reachabilities to be considered. If missing it is found from the initial configuration by taking 1.5 times the maximal minimum reachability of the model with theta=c(1,1). If NULL it will be normed to each configuration's minimum and maximum distance, so an absolute value of goodness-of-clusteredness. Note that the latter is not necessarily desirable when comparing configurations for their relative clusteredness. See also \code{\link{cordillera}}}

\item{optimmethod}{What general purpose optimizer to use? Defaults to our adaptive LJ version (ALJ). Also allows particle swarm optimization with s particles ("pso") and simulated annealing ("SANN"). We recommend not using the latter with the rstress, sstress and the power stress models.}

\item{lower}{The lower contraints of the search region}

\item{upper}{The upper contraints of the search region}

\item{verbose}{numeric value hat prints information on the fitting process; >2 is extremely verbose}

\item{scale}{should the configuration be scaled to mean=0 and sd=1? Defaults to TRUE}

\item{normed}{should the cordillera be normed; defaults to TRUE}

\item{s}{number of particles if pso is used}

\item{stresstype}{what stress to be used for comparisons between solutions}

\item{...}{additional arguments to be passed to the optimization procedure}
}
\value{
A list with the components
        \itemize{
        \item coploss: the weighted loss value
        \item OC: the Optics cordillera
        \item optim: the object returned from the optimization procedure
        \item stress: the stress
        \item stress.m: default normalized stress
        \item parameters: the parameters used for fitting (kappa, lambda)
        \item fit: the returned object of the fitting procedure
        \item cordillera: the cordillera object
}
}
\description{
Metaparameter selection for MDS models baseed on the Profile COPS approach (COPS Variant 2). It uses coploss for hyperparameter selection. It is a special case of a STOPS model.
}
\examples{
dis<-as.matrix(smacof::kinshipdelta)
set.seed(210485)
res1<-pcops(dis,loss="strain",lower=0.1,upper=5,minpts=2) #optimum around lambda=0.16
res1
summary(res1)
plot(res1)
#only use cordillera for finding the parameters; 
res2<-pcops(dis,loss="strain",stressweight=0,lower=0.1,upper=5,minpts=2) #optimum around lambda=0.156
res2
summary(res2)
plot(res2)

#cordillera value of res1 and res 2 very close but res 2 is a bit more clustered
#the reason is the distance between sister and son

#procrustes adjusted
resadj<-conf_adjust(res2$fit$points,res1$fit$points)
plot(resadj$ref.conf) #res 2
plot(resadj$other.conf) #res 1

par(mfrow=c(1,2))
plot(res1,"reachplot")
plot(res2,"reachplot")
par(mfrow=c(1,1))

\donttest{
# From De Leuuw et al (2016) example 7.2.
#They look at different rstress versions and compare how clustered the configuration is
#where stress is minimal and that stress is a monotonically increasing function of r;
dats <- c(5.63,5.27, 6.72,4.60, 5.64, 5.46,4.80, 6.22, 4.97, 3.20,7.54 ,5.12, 8.13, 7.84 ,7.80, 6.73 ,4.59 ,7.55, 6.73, 7.08, 4.08, 7.18 ,7.22 ,6.90 ,7.28 ,6.96 ,6.34 ,6.88, 6.17, 5.47, 4.67, 6.13, 6.04 ,7.42, 6.36, 7.36)
num_cols <- (1 + sqrt(1 + 8*length(dats)))/2 - 1
mat <- matrix(0, num_cols, num_cols)
mat[row(mat) <= col(mat)] <- dats
mat <- t(mat)
mat <- rbind(0, mat)
mat <- cbind(mat, 0)
colnames(mat) <- rownames(mat) <- c(" KVP", "PvdA" , "VVD" , "ARP" , "CHU" , "CPN" , "PSP" ,  "BP", "D66")
dobj <- as.dist(mat)
dobj
#We can do this in one go by setting cordweight to 0 and find that stress is minimal (0.0033) around r~=0.17 (kappa~=0.34)
#and that stress appears thus not monotonically increasing in r
set.seed(210485)
m1 <- pcops(dobj,loss="rstress",lower=c(0.05,1,1),upper=c(5,1,1),verbose=3,cordweight=0,stressweight=1)
m1
# They observe increasing clustering for larger r which we can again do systematically:
# When only clusteredness is of interest, we use cordweight=1 stressweight=0 and try clusters of at least k=2 and k=3 observations
set.seed(210485)
m2 <- pcops(dobj,loss="rstress",minpts=2,lower=c(0.05,1,1),upper=c(5,1,1),verbose=3,cordweight=1,stressweight=0) 
m3 <- pcops(dobj,loss="rstress",minpts=3,lower=c(0.05,1,1),upper=c(5,1,1),verbose=3,cordweight=1,stressweight=0)
m2   #r~=1.24
m3   #r~=1.39

# It is generally better to trade off clusteredness and fit
set.seed(210485)
m2t <- pcops(dobj,loss="rstress",minpts=2,theta=c(m1$par[1],1,1),lower=c(0.05,1,1),upper=c(5,1,1),verbose=3,cordweight=1/3,stressweight=2/3)
m3t <- pcops(dobj,loss="rstress",minpts=3,theta=c(m1$par[1],1,1),lower=c(0.05,1,1),upper=c(5,1,1),verbose=3,cordweight=1/3,stressweight=2/3)
m2t #r~=0.08
m4t #r~=1.39
}

}
\keyword{clustering}
\keyword{multivariate}
